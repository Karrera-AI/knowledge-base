
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../secret-manager/">
      
      
      
        
      
      
      <link rel="icon" href="../assets/favicon.jpeg">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>WORK DNA AI - KarreraAI Docs</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="green" data-md-color-accent="deep-purple">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#work-dna-ai" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="KarreraAI Docs" class="md-header__button md-logo" aria-label="KarreraAI Docs" data-md-component="logo">
      
  <img src="../assets/KarreraLogo.jpeg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            KarreraAI Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              WORK DNA AI
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="green" data-md-color-accent="deep-purple"  aria-label="Dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="deep-orange"  aria-label="Light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="KarreraAI Docs" class="md-nav__button md-logo" aria-label="KarreraAI Docs" data-md-component="logo">
      
  <img src="../assets/KarreraLogo.jpeg" alt="logo">

    </a>
    KarreraAI Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Welcome to KarreraAI Docs
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Front-Doc/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    FrontEnd - Doc
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Personal-AI-APIs/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Personal-AI APIs
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Runbook/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Karrera Infra Runbook
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../Solid/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Solid
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../WORKDNA_CALCULATIONS/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    WORKDNA CALCULATIONS
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../admonitions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Admonitions
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../cicd/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    CI/CD
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../code-examples/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code examples
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../content-tab/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Content tab
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../diagram-examples/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Diagram Examples
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../gateway/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    API Gateway Setup
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../load-balancer/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Load Balancer Setup
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../memory-system-api/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Memory System API Documentation
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ontology_update_call/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Ontology Update Parameters Guide
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../sbert-chroma/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    SENTENCE EMBEDDINGS &amp; CHROMADB
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../secret-manager/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Secret Manager
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    
  
    WORK DNA AI
  

    
  </span>
  
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    
  
    WORK DNA AI
  

    
  </span>
  
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Overview
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-ontology-creation" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Ontology Creation
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Ontology Creation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#purpose" class="md-nav__link">
    <span class="md-ellipsis">
      
        Purpose
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#structure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Structure
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#loading-the-ontology" class="md-nav__link">
    <span class="md-ellipsis">
      
        Loading the Ontology
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Loading the Ontology">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#responsibilities-of-workdnaprocessorservice" class="md-nav__link">
    <span class="md-ellipsis">
      
        Responsibilities of WorkDNAProcessorService:
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Responsibilities of WorkDNAProcessorService:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-structure-example" class="md-nav__link">
    <span class="md-ellipsis">
      
        Data Structure Example
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#role-in-the-pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      
        Role in the Pipeline
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-capability-table-creation-deduplication" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Capability Table Creation &amp; Deduplication
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Capability Table Creation &amp; Deduplication">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-introduction" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1: Introduction
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-capability-dataset-creation" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.2 Capability Dataset Creation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-embedding-creation" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.3 Embedding Creation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-deduplication-process" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4 Deduplication Process
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3.4 Deduplication Process">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#341-selecting-unique-names-and-rewriting-descriptions-in-an-standardized-way" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4.1 Selecting Unique Names and rewriting descriptions in an standardized way
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#342-minhash-based-similarity-clustering" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4.2 MinHash-Based Similarity Clustering
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#343-embedding-based-semantic-clustering-with-hdbscan" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4.3 Embedding-Based Semantic Clustering with HDBSCAN
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-outputs-of-deduplication-final-capability-table" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.5 Outputs of Deduplication = FINAL CAPABILITY TABLE
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#36-role-in-the-workdna-pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.6 Role in the WorkDNA Pipeline
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#before-talking-about-the-ontology-integration-here-is-the-code-used-for-the-deduplication-process" class="md-nav__link">
    <span class="md-ellipsis">
      
        Before talking about the Ontology Integration, here is the code used for the deduplication process
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#import-pandas-as-pd-import-numpy-as-np-from-datasketch-import-minhash-minhashlsh-from-tqdmauto-import-tqdm-from-cumlcluster-import-hdbscan-dbscan-from-sklearnmetrics-import-pairwise_distances_argmin_min-from-sklearnpreprocessing-import-normalize-import-normalize-import-chromadb-step-1-minhash-deduplication-on-names-def-get_minhashtext-str-num_perm-int-128-minhash-m-minhashnum_permnum_perm-for-token-in-settextlowersplit-mupdatetokenencodeutf8-return-m-def-minhash_clusternames-liststr-threshold-float-08-num_perm-int-128-listliststr-cluster-names-by-minhash-lsh-and-return-list-of-clusters-each-a-list-of-names-lsh-minhashlshthresholdthreshold-num_permnum_perm-minhashes-printindexing-names-with-minhash-for-name-in-tqdmnames-mh-get_minhashname-num_perm-lshinsertname-mh-minhashesname-mh-printquerying-clusters-from-lsh-visited-set-clusters-for-name-in-tqdmnames-if-name-in-visited-continue-cluster-lshqueryminhashesname-clustersappendcluster-visitedupdatecluster-return-clusters-def-get_cluster_representativesclusters-listliststr-name_counts-pdseries-dictstr-str-pick-a-representative-name-per-cluster-the-representative-is-chosen-based-on-the-highest-count-or-the-shortest-string-if-counts-are-equal-or-not-available-returns-map-name-cluster_rep_name-rep_map-for-cluster-in-clusters-get-counts-for-names-in-the-current-cluster-cluster_counts-name_countsreindexcluster-fill_value0-find-the-name-with-the-maximum-count-if-theres-a-tie-min-will-pick-the-one-that-comes-first-alphabetically-but-we-want-to-break-ties-by-shortest-length-so-well-find-max-count-first-max_count-cluster_countsmax-get-all-names-with-the-maximum-count-candidates-cluster_countscluster_counts-max_countindextolist-from-the-candidates-pick-the-one-with-the-shortest-length-rep-mincandidates-keylen-for-name-in-cluster-rep_mapname-rep-return-rep_map-step-2-load-embeddings-and-ids-from-chromadb-def-load_all_embeddingschroma_collection_names-liststr-pddataframe-fetch-all-embeddings-ids-names-from-multiple-chromadb-collections-combine-into-one-dataframe-returns-dataframe-with-columns-id-name-embedding-nparray-chroma_client-chromadbhttpclienthost-3471102215-port-8000-all_data-for-collection_name-in-chroma_collection_names-collection-chroma_clientget_collectioncollection_name-results-collectiongetincludeembeddings-metadatas-ids-unique-ids-in-collection-embeddings-list-of-vectors-ids-resultsids-embeddings-resultsembeddings-metadatas-resultsmetadatas-df-pddataframeid-ids-dfembedding-e-for-e-in-embeddings-dfname-metaname-for-meta-in-metadatas-all_dataappenddf-full_df-pdconcatall_data-ignore_indextrue-remove-duplicate-names-keeping-first-appearance-full_df-full_dfdrop_duplicatessubsetidreset_indexdroptrue-return-full_df-def-load_all_embeddingsname_df-pddataframe-chroma_collection_names-liststr-pddataframe-fetch-all-embeddings-ids-names-from-multiple-chromadb-collections-combine-into-one-dataframe-args-name_df-dataframe-containing-id-and-name-columns-to-match-with-embeddings-chroma_collection_names-list-of-chromadb-collection-names-to-fetch-embeddings-from-returns-dataframe-with-columns-id-name-embedding-nparray-chroma_client-chromadbhttpclienthost3471102215-port8000-create-a-dictionary-to-store-embeddings-by-id-for-faster-lookup-embeddings_dict-for-collection_name-in-chroma_collection_names-try-collection-chroma_clientget_collectioncollection_name-results-collectiongetincludeembeddings-store-each-id-and-its-corresponding-embedding-in-the-dictionary-for-id_-embedding-in-zipresultsids-resultsembeddings-for-id_-embedding-in-zipresultsids-normalizeresultsembeddings-norm-l2-embeddings_dictid_-nparrayembedding-except-exception-as-e-printferror-loading-collection-collection_name-stre-continue-create-a-new-dataframe-with-the-same-rows-as-name_df-full_df-name_dfcopy-add-embeddings-to-the-dataframe-full_dfembedding-full_dfidmapembeddings_dict-drop-rows-where-no-embedding-was-found-if-desired-full_df-full_dfdropnasubsetembedding-return-full_df-step-3-filter-embeddings-to-minhash-cluster-representatives-def-filter_to_representativesfull_df-pddataframe-rep_map-dictstr-str-pddataframe-filter-full_df-rows-to-only-those-whose-name-is-a-cluster-representative-reps-setrep_mapvalues-filtered-full_dffull_dfnameisinrepsreset_indexdroptrue-return-filtered-step-4-hdbscan-clustering-on-embeddings-def-hdbscan_cluster_embeddingsembeddings-npndarray-min_cluster_size-int-5-min_samples-int-none-epsilon_value-float-00-npndarray-run-cuml-hdbscan-clustering-on-embeddings-array-clusterer-hdbscanmin_cluster_sizemin_cluster_size-min_samplesmin_samples-cluster_selection_epsilon-epsilon_value-metric-euclidean-verbose-3-labels-clustererfit_predictembeddings-return-labels-def-dbscan_cluster_embeddingsembeddings-npndarray-min_cluster_size-int-5-min_samples-int-none-epsilon_value-float-00-npndarray-run-cuml-hdbscan-clustering-on-embeddings-array-clusterer-dbscan-min_cluster_sizemin_cluster_size-min_samplesmin_samples-eps-epsilon_value-metric-cosine-verbose-3-labels-clustererfit_predictembeddings-return-labels-step-5-assign-medoid-as-cluster-representative-id-def-assign_medoid_representativeembeddings-npndarray-labels-npndarray-ids-liststr-dictint-str-for-each-cluster-find-medoid-closest-embedding-to-cluster-centroid-returns-dict-cluster_label-medoid_id-cluster_medoid-for-cluster_label-in-setlabels-if-cluster_label-1-noise-cluster-no-medoid-continue-cluster_indices-npwherelabels-cluster_label0-cluster_embeds-embeddingscluster_indices-compute-centroid-centroid-cluster_embedsmeanaxis0reshape1-1-find-closest-embedding-to-centroid-medoid-medoid_idx-_-pairwise_distances_argmin_mincentroid-cluster_embeds-medoid_id-idscluster_indicesmedoid_idx0-cluster_medoidcluster_label-medoid_id-return-cluster_medoid-def-assign_count_based_representativerep_df-pddataframe-cluster_labels-npndarray-dictint-str-for-each-cluster-find-the-representative-with-the-highest-count-if-count-column-is-not-available-falls-back-to-medoid-logic-returns-dict-cluster_label-count_based_rep_id-cluster_rep_ids-if-count-not-in-rep_dfcolumns-printwarning-count-column-not-found-in-representative-dataframe-falling-back-to-medoid-based-representatives-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-return-assign_medoid_representativeembeddings_array-cluster_labels-rep_dfidtolist-for-cluster_label-in-setcluster_labels-if-cluster_label-1-continue-cluster_rows-rep_dfcluster_labels-cluster_label-find-the-row-with-the-maximum-count-in-case-of-a-tie-idxmax-will-return-the-first-occurrence-which-is-fine-max_count_row-cluster_rowsloccluster_rowscountidxmax-cluster_rep_idscluster_label-max_count_rowid-return-cluster_rep_ids-step-6-build-final-dataframe-with-cluster_id-and-cluster_rep_id-per-original-id-def-build_final_mapping-full_df-pddataframe-rep_df-pddataframe-rep_map-dictstr-str-cluster_labels-npndarray-use_count_rep-bool-false-pddataframe-assign-cluster_id-and-cluster_rep_id-for-all-original-ids-args-full_df-dataframe-with-all-original-ids-names-embeddings-and-optionally-a-count-column-rep_df-dataframe-with-representatives-only-their-embeddings-and-cluster-labels-rep_map-map-original-name-representative-name-string-cluster_labels-hdbscan-cluster-labels-for-rep_df-rows-use_count_rep-if-true-uses-the-highest-count-item-as-cluster-representative-otherwise-uses-the-medoid-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-count-if-present-in-input-rep_df-rep_dfcopy-rep_dfcluster_id-cluster_labels-choose-representative-assignment-method-if-use_count_rep-and-count-in-rep_dfcolumns-printassigning-cluster-representatives-based-on-highest-count-cluster_rep_map-assign_count_based_representativerep_df-cluster_labels-else-printassigning-cluster-representatives-based-on-medoid-closest-to-centroid-embeddings_array-npvstackrep_dfembeddingtolist-cluster_rep_map-assign_medoid_representativeembeddings_array-cluster_labels-rep_dfidtolist-map-representative-name-to-id-rep_name_to_id-dictziprep_dfname-rep_dfid-rows-noise_count-0-total-lenfull_df-total_count-0-for-_-row-in-full_dfiterrows-name-rowname-orig_id-rowid-count-rowgetcount-1-default-to-1-if-no-count-column-total_count-count-rep_name-rep_mapgetname-name-rep_id-rep_name_to_idgetrep_name-cluster_id-none-if-rep_id-rep_cluster_idx-rep_dfindexrep_dfid-rep_id-if-lenrep_cluster_idx-1-cluster_id-rep_dflocrep_cluster_idx0-cluster_id-if-cluster_id-1-cluster_rep_id-rep_id-noise_count-1-else-cluster_rep_id-cluster_rep_mapgetcluster_id-rep_id-row_data-id-orig_id-name-name-cluster_id-cluster_id-cluster_rep_id-cluster_rep_id-if-count-in-full_dfcolumns-row_datacount-count-rowsappendrow_data-result_df-pddataframerows-log-cluster-summary-num_clusters-lensetcluster_labels-1-if-1-in-cluster_labels-else-0-printf-mapping-complete-total-rows-total_count-total-count-printf-num_clusters-clusters-formed-printf-noise_count-items-marked-as-noise-singleton-clusters-optional-summary-of-total-count-per-cluster-rep-if-count-in-result_dfcolumns-cluster_summary-result_dfgroupbycluster_rep_idcount-sum-sort_valuesascendingfalse-printn-top-cluster-representatives-by-total-count-printcluster_summaryhead10-return-result_df-main-pipeline-function-def-full_deduplication_pipeline-all_names-liststr-full_df-pddataframe-minhash_threshold-float-08-num_perm-int-128-hdbscan_min_cluster_size-int-5-hdbscan_min_samples-int-none-epsilon_valuefloat-00-use_count_rep-bool-false-pddataframe-run-full-deduplication-pipeline-1-minhash-deduplication-on-names-2-load-embeddings-and-ids-from-chromadb-collections-this-wil-be-done-before-3-filter-embeddings-to-minhash-cluster-representatives-4-run-hdbscan-on-embeddings-of-representatives-5-assign-medoid-representatives-per-cluster-6-map-all-original-ids-to-cluster_id-and-cluster_rep_id-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-printrunning-minhash-deduplication-on-names-get-a-series-of-counts-for-minhash-clustering-representative-selection-if-count-in-full_dfcolumns-name_counts-full_dfgroupbynamecountsum-else-name_counts-pdseries1-indexfull_dfnameunique-clusters-minhash_clusterall_names-thresholdminhash_threshold-num_permnum_perm-rep_map-get_cluster_representativesclusters-name_counts-printffiltering-embeddings-to-lensetrep_mapvalues-cluster-representatives-rep_df-filter_to_representativesfull_df-rep_map-printrunning-hdbscan-on-representative-embeddings-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-cluster_labels-hdbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-epsilon_value-epsilon_value-cluster_labels-dbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-epsilon_value-epsilon_value-printbuilding-final-mapping-of-all-ids-to-cluster-ids-and-representative-ids-final_df-build_final_mappingfull_df-rep_df-rep_map-cluster_labels-use_count_repuse_count_rep-return-final_df-def-deduplication_pipeline_testing-all_names-liststr-full_df-pddataframe-rep_map-hdbscan_min_cluster_size-int-5-hdbscan_min_samples-int-none-pddataframe-run-full-deduplication-pipeline-1-minhash-deduplication-on-names-2-load-embeddings-and-ids-from-chromadb-collections-this-wil-be-done-before-3-filter-embeddings-to-minhash-cluster-representatives-4-run-hdbscan-on-embeddings-of-representatives-5-assign-medoid-representatives-per-cluster-6-map-all-original-ids-to-cluster_id-and-cluster_rep_id-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-printffiltering-embeddings-to-lensetrep_mapvalues-cluster-representatives-rep_df-filter_to_representativesfull_df-rep_map-printrunning-hdbscan-on-representative-embeddings-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-cluster_labels-hdbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-printbuilding-final-mapping-of-all-ids-to-cluster-ids-and-representative-ids-final_df-build_final_mappingfull_df-rep_df-rep_map-cluster_labels-return-final_df" class="md-nav__link">
    <span class="md-ellipsis">
      
        import pandas as pd import numpy as np from datasketch import MinHash, MinHashLSH from tqdm.auto import tqdm from cuml.cluster import HDBSCAN, DBSCAN from sklearn.metrics import pairwise_distances_argmin_min from sklearn.preprocessing import normalize # Import normalize import chromadb # ---------------------------------------- # Step 1: MinHash Deduplication on Names # ---------------------------------------- def get_minhash(text: str, num_perm: int = 128) -&gt; MinHash: m = MinHash(num_perm=num_perm) for token in set(text.lower().split()): m.update(token.encode(&#39;utf8&#39;)) return m def minhash_cluster(names: list[str], threshold: float = 0.8, num_perm: int = 128) -&gt; list[list[str]]: &quot;&quot;&quot; Cluster names by MinHash + LSH and return list of clusters (each a list of names). &quot;&quot;&quot; lsh = MinHashLSH(threshold=threshold, num_perm=num_perm) minhashes = {} print(&quot;Indexing names with MinHash...&quot;) for name in tqdm(names): mh = get_minhash(name, num_perm) lsh.insert(name, mh) minhashes[name] = mh print(&quot;Querying clusters from LSH...&quot;) visited = set() clusters = [] for name in tqdm(names): if name in visited: continue cluster = lsh.query(minhashes[name]) clusters.append(cluster) visited.update(cluster) return clusters def get_cluster_representatives(clusters: list[list[str]], name_counts: pd.Series) -&gt; dict[str, str]: &quot;&quot;&quot; Pick a representative name per cluster. The representative is chosen based on the highest count, or the shortest string if counts are equal or not available. Returns map: name -&gt; cluster_rep_name &quot;&quot;&quot; rep_map = {} for cluster in clusters: # Get counts for names in the current cluster cluster_counts = name_counts.reindex(cluster, fill_value=0) # Find the name with the maximum count # If there&#39;s a tie, min() will pick the one that comes first alphabetically, # but we want to break ties by shortest length. So we&#39;ll find max count first. max_count = cluster_counts.max() # Get all names with the maximum count candidates = cluster_counts[cluster_counts == max_count].index.tolist() # From the candidates, pick the one with the shortest length rep = min(candidates, key=len) for name in cluster: rep_map[name] = rep return rep_map # ---------------------------------------- # Step 2: Load Embeddings and IDs from ChromaDB # ---------------------------------------- # def load_all_embeddings(chroma_collection_names: list[str]) -&gt; pd.DataFrame: # &quot;&quot;&quot; # Fetch all embeddings + ids + names from multiple ChromaDB collections, combine into one DataFrame. # Returns DataFrame with columns: id, name, embedding (np.array) # &quot;&quot;&quot; # chroma_client = chromadb.HttpClient(host = &#39;34.71.102.215&#39;, port = 8000) # all_data = [] # for collection_name in chroma_collection_names: # collection = chroma_client.get_collection(collection_name) # results = collection.get(include=[&quot;embeddings&quot;, &#39;metadatas&#39;]) # # ids = unique IDs in collection # # embeddings = list of vectors # ids = results[&quot;ids&quot;] # embeddings = results[&quot;embeddings&quot;] # metadatas = results[&#39;metadatas&#39;] # df = pd.DataFrame({&quot;id&quot;: ids}) # df[&quot;embedding&quot;] = [e for e in embeddings] # df[&#39;name&#39;] = [meta[&#39;name&#39;] for meta in metadatas] # all_data.append(df) # full_df = pd.concat(all_data, ignore_index=True) # # Remove duplicate names keeping first appearance # full_df = full_df.drop_duplicates(subset=&quot;id&quot;).reset_index(drop=True) # return full_df def load_all_embeddings(name_df: pd.DataFrame, chroma_collection_names: list[str]) -&gt; pd.DataFrame: &quot;&quot;&quot; Fetch all embeddings + ids + names from multiple ChromaDB collections, combine into one DataFrame. Args: name_df: DataFrame containing &#39;id&#39; and &#39;name&#39; columns to match with embeddings chroma_collection_names: List of ChromaDB collection names to fetch embeddings from Returns: DataFrame with columns: id, name, embedding (np.array) &quot;&quot;&quot; chroma_client = chromadb.HttpClient(host=&#39;34.71.102.215&#39;, port=8000) # Create a dictionary to store embeddings by ID for faster lookup embeddings_dict = {} for collection_name in chroma_collection_names: try: collection = chroma_client.get_collection(collection_name) results = collection.get(include=[&quot;embeddings&quot;]) # Store each id and its corresponding embedding in the dictionary # for id_, embedding in zip(results[&quot;ids&quot;], results[&quot;embeddings&quot;]): for id_, embedding in zip(results[&quot;ids&quot;], normalize(results[&quot;embeddings&quot;], norm = &#39;l2&#39;)): embeddings_dict[id_] = np.array(embedding) except Exception as e: print(f&quot;Error loading collection {collection_name}: {str(e)}&quot;) continue # Create a new DataFrame with the same rows as name_df full_df = name_df.copy() # Add embeddings to the DataFrame full_df[&#39;embedding&#39;] = full_df[&#39;id&#39;].map(embeddings_dict) # Drop rows where no embedding was found (if desired) full_df = full_df.dropna(subset=[&#39;embedding&#39;]) return full_df # ---------------------------------------- # Step 3: Filter Embeddings to MinHash Cluster Representatives # ---------------------------------------- def filter_to_representatives(full_df: pd.DataFrame, rep_map: dict[str, str]) -&gt; pd.DataFrame: &quot;&quot;&quot; Filter full_df rows to only those whose name is a cluster representative. &quot;&quot;&quot; reps = set(rep_map.values()) filtered = full_df[full_df[&quot;name&quot;].isin(reps)].reset_index(drop=True) return filtered # ---------------------------------------- # Step 4: HDBSCAN Clustering on Embeddings # ---------------------------------------- def hdbscan_cluster_embeddings(embeddings: np.ndarray, min_cluster_size: int = 5, min_samples: int = None, epsilon_value: float = 0.0) -&gt; np.ndarray: &quot;&quot;&quot; Run cuML HDBSCAN clustering on embeddings array. &quot;&quot;&quot; clusterer = HDBSCAN(min_cluster_size=min_cluster_size, min_samples=min_samples, cluster_selection_epsilon = epsilon_value, metric = &#39;euclidean&#39;, verbose = 3 ) labels = clusterer.fit_predict(embeddings) return labels def dbscan_cluster_embeddings(embeddings: np.ndarray, min_cluster_size: int = 5, min_samples: int = None, epsilon_value: float = 0.0) -&gt; np.ndarray: &quot;&quot;&quot; Run cuML HDBSCAN clustering on embeddings array. &quot;&quot;&quot; clusterer = DBSCAN( # min_cluster_size=min_cluster_size, min_samples=min_samples, eps = epsilon_value, metric = &#39;cosine&#39;, verbose = 3 ) labels = clusterer.fit_predict(embeddings) return labels # ---------------------------------------- # Step 5: Assign Medoid as Cluster Representative ID # ---------------------------------------- def assign_medoid_representative(embeddings: np.ndarray, labels: np.ndarray, ids: list[str]) -&gt; dict[int, str]: &quot;&quot;&quot; For each cluster, find medoid (closest embedding to cluster centroid). Returns dict: cluster_label -&gt; medoid_id &quot;&quot;&quot; cluster_medoid = {} for cluster_label in set(labels): if cluster_label == -1: # Noise cluster: no medoid continue cluster_indices = np.where(labels == cluster_label)[0] cluster_embeds = embeddings[cluster_indices] # Compute centroid centroid = cluster_embeds.mean(axis=0).reshape(1, -1) # Find closest embedding to centroid (medoid) medoid_idx, _ = pairwise_distances_argmin_min(centroid, cluster_embeds) medoid_id = ids[cluster_indices[medoid_idx[0]]] cluster_medoid[cluster_label] = medoid_id return cluster_medoid def assign_count_based_representative(rep_df: pd.DataFrame, cluster_labels: np.ndarray) -&gt; dict[int, str]: &quot;&quot;&quot; For each cluster, find the representative with the highest count. If &#39;count&#39; column is not available, falls back to medoid logic. Returns dict: cluster_label -&gt; count_based_rep_id &quot;&quot;&quot; cluster_rep_ids = {} if &quot;count&quot; not in rep_df.columns: print(&quot;Warning: &#39;count&#39; column not found in representative DataFrame. Falling back to medoid-based representatives.&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].values).astype(np.float32) return assign_medoid_representative(embeddings_array, cluster_labels, rep_df[&quot;id&quot;].tolist()) for cluster_label in set(cluster_labels): if cluster_label == -1: continue cluster_rows = rep_df[cluster_labels == cluster_label] # Find the row with the maximum count # In case of a tie, `idxmax` will return the first occurrence, which is fine max_count_row = cluster_rows.loc[cluster_rows[&quot;count&quot;].idxmax()] cluster_rep_ids[cluster_label] = max_count_row[&quot;id&quot;] return cluster_rep_ids # ---------------------------------------- # Step 6: Build Final DataFrame with cluster_id and cluster_rep_id per original id # ---------------------------------------- def build_final_mapping( full_df: pd.DataFrame, rep_df: pd.DataFrame, rep_map: dict[str, str], cluster_labels: np.ndarray, use_count_rep: bool = False ) -&gt; pd.DataFrame: &quot;&quot;&quot; Assign cluster_id and cluster_rep_id for all original ids. Args: full_df: DataFrame with all original ids, names, embeddings, and optionally a &#39;count&#39; column. rep_df: DataFrame with representatives only, their embeddings and cluster labels. rep_map: map original name -&gt; representative name (string) cluster_labels: HDBSCAN cluster labels for rep_df rows. use_count_rep: If True, uses the highest-count item as cluster representative. Otherwise, uses the medoid. Returns: DataFrame with columns: id, name, cluster_id, cluster_rep_id, count (if present in input) &quot;&quot;&quot; rep_df = rep_df.copy() rep_df[&quot;cluster_id&quot;] = cluster_labels # Choose representative assignment method if use_count_rep and &quot;count&quot; in rep_df.columns: print(&quot;Assigning cluster representatives based on highest count...&quot;) cluster_rep_map = assign_count_based_representative(rep_df, cluster_labels) else: print(&quot;Assigning cluster representatives based on medoid (closest to centroid)...&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].tolist()) cluster_rep_map = assign_medoid_representative(embeddings_array, cluster_labels, rep_df[&quot;id&quot;].tolist()) # Map representative name to ID rep_name_to_id = dict(zip(rep_df[&quot;name&quot;], rep_df[&quot;id&quot;])) rows = [] noise_count = 0 total = len(full_df) total_count = 0 for _, row in full_df.iterrows(): name = row[&quot;name&quot;] orig_id = row[&quot;id&quot;] count = row.get(&quot;count&quot;, 1) # Default to 1 if no count column total_count += count rep_name = rep_map.get(name, name) rep_id = rep_name_to_id.get(rep_name) cluster_id = None if rep_id: rep_cluster_idx = rep_df.index[rep_df[&quot;id&quot;] == rep_id] if len(rep_cluster_idx) == 1: cluster_id = rep_df.loc[rep_cluster_idx[0], &quot;cluster_id&quot;] if cluster_id == -1: cluster_rep_id = rep_id noise_count += 1 else: cluster_rep_id = cluster_rep_map.get(cluster_id, rep_id) row_data = { &quot;id&quot;: orig_id, &quot;name&quot;: name, &quot;cluster_id&quot;: cluster_id, &quot;cluster_rep_id&quot;: cluster_rep_id, } if &quot;count&quot; in full_df.columns: row_data[&quot;count&quot;] = count rows.append(row_data) result_df = pd.DataFrame(rows) # Log cluster summary num_clusters = len(set(cluster_labels)) - (1 if -1 in cluster_labels else 0) print(f&quot;‚úÖ Mapping complete: {total} rows, {total_count} total count&quot;) print(f&quot;üì¶ {num_clusters} clusters formed&quot;) print(f&quot;üå™Ô∏è {noise_count} items marked as noise (singleton clusters)&quot;) # Optional: Summary of total count per cluster rep if &quot;count&quot; in result_df.columns: cluster_summary = ( result_df.groupby(&quot;cluster_rep_id&quot;)[&quot;count&quot;] .sum() .sort_values(ascending=False) ) print(&quot;\nüî¢ Top cluster representatives by total count:&quot;) print(cluster_summary.head(10)) return result_df # ---------------------------------------- # Main pipeline function # ---------------------------------------- def full_deduplication_pipeline( all_names: list[str], full_df: pd.DataFrame, minhash_threshold: float = 0.8, num_perm: int = 128, hdbscan_min_cluster_size: int = 5, hdbscan_min_samples: int = None, epsilon_value:float = 0.0, use_count_rep: bool = False ) -&gt; pd.DataFrame: &quot;&quot;&quot; Run full deduplication pipeline: 1. MinHash deduplication on names 2. Load embeddings and IDs from ChromaDB collections -- this wil be done before 3. Filter embeddings to MinHash cluster representatives 4. Run HDBSCAN on embeddings of representatives 5. Assign medoid representatives per cluster 6. Map all original ids to cluster_id and cluster_rep_id Returns: DataFrame with columns: id, name, cluster_id, cluster_rep_id &quot;&quot;&quot; print(&quot;Running MinHash deduplication on names...&quot;) # Get a Series of counts for MinHash clustering representative selection if &quot;count&quot; in full_df.columns: name_counts = full_df.groupby(&quot;name&quot;)[&quot;count&quot;].sum() else: name_counts = pd.Series(1, index=full_df[&quot;name&quot;].unique()) clusters = minhash_cluster(all_names, threshold=minhash_threshold, num_perm=num_perm) rep_map = get_cluster_representatives(clusters, name_counts) print(f&quot;Filtering embeddings to {len(set(rep_map.values()))} cluster representatives...&quot;) rep_df = filter_to_representatives(full_df, rep_map) print(&quot;Running HDBSCAN on representative embeddings...&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].values).astype(np.float32) cluster_labels = hdbscan_cluster_embeddings( embeddings_array, min_cluster_size=hdbscan_min_cluster_size, min_samples=hdbscan_min_samples, epsilon_value = epsilon_value ) # cluster_labels = dbscan_cluster_embeddings( # embeddings_array, # min_cluster_size=hdbscan_min_cluster_size, # min_samples=hdbscan_min_samples, # epsilon_value = epsilon_value # ) print(&quot;Building final mapping of all IDs to cluster IDs and representative IDs...&quot;) final_df = build_final_mapping(full_df, rep_df, rep_map, cluster_labels, use_count_rep=use_count_rep) return final_df def deduplication_pipeline_testing( all_names: list[str], full_df: pd.DataFrame, rep_map, hdbscan_min_cluster_size: int = 5, hdbscan_min_samples: int = None, ) -&gt; pd.DataFrame: &quot;&quot;&quot; Run full deduplication pipeline: 1. MinHash deduplication on names 2. Load embeddings and IDs from ChromaDB collections -- this wil be done before 3. Filter embeddings to MinHash cluster representatives 4. Run HDBSCAN on embeddings of representatives 5. Assign medoid representatives per cluster 6. Map all original ids to cluster_id and cluster_rep_id Returns: DataFrame with columns: id, name, cluster_id, cluster_rep_id &quot;&quot;&quot; print(f&quot;Filtering embeddings to {len(set(rep_map.values()))} cluster representatives...&quot;) rep_df = filter_to_representatives(full_df, rep_map) print(&quot;Running HDBSCAN on representative embeddings...&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].values).astype(np.float32) cluster_labels = hdbscan_cluster_embeddings( embeddings_array, min_cluster_size=hdbscan_min_cluster_size, min_samples=hdbscan_min_samples ) print(&quot;Building final mapping of all IDs to cluster IDs and representative IDs...&quot;) final_df = build_final_mapping(full_df, rep_df, rep_map, cluster_labels) return final_df
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-workdna-ontology-service" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. WorkDNA Ontology Service
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. WorkDNA Ontology Service">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-structure-of-the-ontology" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1 Structure of the Ontology
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#41-purpose" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1 Purpose
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1-overview" class="md-nav__link">
    <span class="md-ellipsis">
      
        1. Overview
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-ontology-creation" class="md-nav__link">
    <span class="md-ellipsis">
      
        2. Ontology Creation
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Ontology Creation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#purpose" class="md-nav__link">
    <span class="md-ellipsis">
      
        Purpose
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#structure" class="md-nav__link">
    <span class="md-ellipsis">
      
        Structure
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#loading-the-ontology" class="md-nav__link">
    <span class="md-ellipsis">
      
        Loading the Ontology
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Loading the Ontology">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#responsibilities-of-workdnaprocessorservice" class="md-nav__link">
    <span class="md-ellipsis">
      
        Responsibilities of WorkDNAProcessorService:
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Responsibilities of WorkDNAProcessorService:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-structure-example" class="md-nav__link">
    <span class="md-ellipsis">
      
        Data Structure Example
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#role-in-the-pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      
        Role in the Pipeline
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-capability-table-creation-deduplication" class="md-nav__link">
    <span class="md-ellipsis">
      
        3. Capability Table Creation &amp; Deduplication
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3. Capability Table Creation &amp; Deduplication">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-introduction" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.1: Introduction
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-capability-dataset-creation" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.2 Capability Dataset Creation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-embedding-creation" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.3 Embedding Creation
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-deduplication-process" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4 Deduplication Process
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="3.4 Deduplication Process">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#341-selecting-unique-names-and-rewriting-descriptions-in-an-standardized-way" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4.1 Selecting Unique Names and rewriting descriptions in an standardized way
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#342-minhash-based-similarity-clustering" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4.2 MinHash-Based Similarity Clustering
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#343-embedding-based-semantic-clustering-with-hdbscan" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.4.3 Embedding-Based Semantic Clustering with HDBSCAN
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-outputs-of-deduplication-final-capability-table" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.5 Outputs of Deduplication = FINAL CAPABILITY TABLE
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#36-role-in-the-workdna-pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      
        3.6 Role in the WorkDNA Pipeline
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#before-talking-about-the-ontology-integration-here-is-the-code-used-for-the-deduplication-process" class="md-nav__link">
    <span class="md-ellipsis">
      
        Before talking about the Ontology Integration, here is the code used for the deduplication process
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#import-pandas-as-pd-import-numpy-as-np-from-datasketch-import-minhash-minhashlsh-from-tqdmauto-import-tqdm-from-cumlcluster-import-hdbscan-dbscan-from-sklearnmetrics-import-pairwise_distances_argmin_min-from-sklearnpreprocessing-import-normalize-import-normalize-import-chromadb-step-1-minhash-deduplication-on-names-def-get_minhashtext-str-num_perm-int-128-minhash-m-minhashnum_permnum_perm-for-token-in-settextlowersplit-mupdatetokenencodeutf8-return-m-def-minhash_clusternames-liststr-threshold-float-08-num_perm-int-128-listliststr-cluster-names-by-minhash-lsh-and-return-list-of-clusters-each-a-list-of-names-lsh-minhashlshthresholdthreshold-num_permnum_perm-minhashes-printindexing-names-with-minhash-for-name-in-tqdmnames-mh-get_minhashname-num_perm-lshinsertname-mh-minhashesname-mh-printquerying-clusters-from-lsh-visited-set-clusters-for-name-in-tqdmnames-if-name-in-visited-continue-cluster-lshqueryminhashesname-clustersappendcluster-visitedupdatecluster-return-clusters-def-get_cluster_representativesclusters-listliststr-name_counts-pdseries-dictstr-str-pick-a-representative-name-per-cluster-the-representative-is-chosen-based-on-the-highest-count-or-the-shortest-string-if-counts-are-equal-or-not-available-returns-map-name-cluster_rep_name-rep_map-for-cluster-in-clusters-get-counts-for-names-in-the-current-cluster-cluster_counts-name_countsreindexcluster-fill_value0-find-the-name-with-the-maximum-count-if-theres-a-tie-min-will-pick-the-one-that-comes-first-alphabetically-but-we-want-to-break-ties-by-shortest-length-so-well-find-max-count-first-max_count-cluster_countsmax-get-all-names-with-the-maximum-count-candidates-cluster_countscluster_counts-max_countindextolist-from-the-candidates-pick-the-one-with-the-shortest-length-rep-mincandidates-keylen-for-name-in-cluster-rep_mapname-rep-return-rep_map-step-2-load-embeddings-and-ids-from-chromadb-def-load_all_embeddingschroma_collection_names-liststr-pddataframe-fetch-all-embeddings-ids-names-from-multiple-chromadb-collections-combine-into-one-dataframe-returns-dataframe-with-columns-id-name-embedding-nparray-chroma_client-chromadbhttpclienthost-3471102215-port-8000-all_data-for-collection_name-in-chroma_collection_names-collection-chroma_clientget_collectioncollection_name-results-collectiongetincludeembeddings-metadatas-ids-unique-ids-in-collection-embeddings-list-of-vectors-ids-resultsids-embeddings-resultsembeddings-metadatas-resultsmetadatas-df-pddataframeid-ids-dfembedding-e-for-e-in-embeddings-dfname-metaname-for-meta-in-metadatas-all_dataappenddf-full_df-pdconcatall_data-ignore_indextrue-remove-duplicate-names-keeping-first-appearance-full_df-full_dfdrop_duplicatessubsetidreset_indexdroptrue-return-full_df-def-load_all_embeddingsname_df-pddataframe-chroma_collection_names-liststr-pddataframe-fetch-all-embeddings-ids-names-from-multiple-chromadb-collections-combine-into-one-dataframe-args-name_df-dataframe-containing-id-and-name-columns-to-match-with-embeddings-chroma_collection_names-list-of-chromadb-collection-names-to-fetch-embeddings-from-returns-dataframe-with-columns-id-name-embedding-nparray-chroma_client-chromadbhttpclienthost3471102215-port8000-create-a-dictionary-to-store-embeddings-by-id-for-faster-lookup-embeddings_dict-for-collection_name-in-chroma_collection_names-try-collection-chroma_clientget_collectioncollection_name-results-collectiongetincludeembeddings-store-each-id-and-its-corresponding-embedding-in-the-dictionary-for-id_-embedding-in-zipresultsids-resultsembeddings-for-id_-embedding-in-zipresultsids-normalizeresultsembeddings-norm-l2-embeddings_dictid_-nparrayembedding-except-exception-as-e-printferror-loading-collection-collection_name-stre-continue-create-a-new-dataframe-with-the-same-rows-as-name_df-full_df-name_dfcopy-add-embeddings-to-the-dataframe-full_dfembedding-full_dfidmapembeddings_dict-drop-rows-where-no-embedding-was-found-if-desired-full_df-full_dfdropnasubsetembedding-return-full_df-step-3-filter-embeddings-to-minhash-cluster-representatives-def-filter_to_representativesfull_df-pddataframe-rep_map-dictstr-str-pddataframe-filter-full_df-rows-to-only-those-whose-name-is-a-cluster-representative-reps-setrep_mapvalues-filtered-full_dffull_dfnameisinrepsreset_indexdroptrue-return-filtered-step-4-hdbscan-clustering-on-embeddings-def-hdbscan_cluster_embeddingsembeddings-npndarray-min_cluster_size-int-5-min_samples-int-none-epsilon_value-float-00-npndarray-run-cuml-hdbscan-clustering-on-embeddings-array-clusterer-hdbscanmin_cluster_sizemin_cluster_size-min_samplesmin_samples-cluster_selection_epsilon-epsilon_value-metric-euclidean-verbose-3-labels-clustererfit_predictembeddings-return-labels-def-dbscan_cluster_embeddingsembeddings-npndarray-min_cluster_size-int-5-min_samples-int-none-epsilon_value-float-00-npndarray-run-cuml-hdbscan-clustering-on-embeddings-array-clusterer-dbscan-min_cluster_sizemin_cluster_size-min_samplesmin_samples-eps-epsilon_value-metric-cosine-verbose-3-labels-clustererfit_predictembeddings-return-labels-step-5-assign-medoid-as-cluster-representative-id-def-assign_medoid_representativeembeddings-npndarray-labels-npndarray-ids-liststr-dictint-str-for-each-cluster-find-medoid-closest-embedding-to-cluster-centroid-returns-dict-cluster_label-medoid_id-cluster_medoid-for-cluster_label-in-setlabels-if-cluster_label-1-noise-cluster-no-medoid-continue-cluster_indices-npwherelabels-cluster_label0-cluster_embeds-embeddingscluster_indices-compute-centroid-centroid-cluster_embedsmeanaxis0reshape1-1-find-closest-embedding-to-centroid-medoid-medoid_idx-_-pairwise_distances_argmin_mincentroid-cluster_embeds-medoid_id-idscluster_indicesmedoid_idx0-cluster_medoidcluster_label-medoid_id-return-cluster_medoid-def-assign_count_based_representativerep_df-pddataframe-cluster_labels-npndarray-dictint-str-for-each-cluster-find-the-representative-with-the-highest-count-if-count-column-is-not-available-falls-back-to-medoid-logic-returns-dict-cluster_label-count_based_rep_id-cluster_rep_ids-if-count-not-in-rep_dfcolumns-printwarning-count-column-not-found-in-representative-dataframe-falling-back-to-medoid-based-representatives-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-return-assign_medoid_representativeembeddings_array-cluster_labels-rep_dfidtolist-for-cluster_label-in-setcluster_labels-if-cluster_label-1-continue-cluster_rows-rep_dfcluster_labels-cluster_label-find-the-row-with-the-maximum-count-in-case-of-a-tie-idxmax-will-return-the-first-occurrence-which-is-fine-max_count_row-cluster_rowsloccluster_rowscountidxmax-cluster_rep_idscluster_label-max_count_rowid-return-cluster_rep_ids-step-6-build-final-dataframe-with-cluster_id-and-cluster_rep_id-per-original-id-def-build_final_mapping-full_df-pddataframe-rep_df-pddataframe-rep_map-dictstr-str-cluster_labels-npndarray-use_count_rep-bool-false-pddataframe-assign-cluster_id-and-cluster_rep_id-for-all-original-ids-args-full_df-dataframe-with-all-original-ids-names-embeddings-and-optionally-a-count-column-rep_df-dataframe-with-representatives-only-their-embeddings-and-cluster-labels-rep_map-map-original-name-representative-name-string-cluster_labels-hdbscan-cluster-labels-for-rep_df-rows-use_count_rep-if-true-uses-the-highest-count-item-as-cluster-representative-otherwise-uses-the-medoid-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-count-if-present-in-input-rep_df-rep_dfcopy-rep_dfcluster_id-cluster_labels-choose-representative-assignment-method-if-use_count_rep-and-count-in-rep_dfcolumns-printassigning-cluster-representatives-based-on-highest-count-cluster_rep_map-assign_count_based_representativerep_df-cluster_labels-else-printassigning-cluster-representatives-based-on-medoid-closest-to-centroid-embeddings_array-npvstackrep_dfembeddingtolist-cluster_rep_map-assign_medoid_representativeembeddings_array-cluster_labels-rep_dfidtolist-map-representative-name-to-id-rep_name_to_id-dictziprep_dfname-rep_dfid-rows-noise_count-0-total-lenfull_df-total_count-0-for-_-row-in-full_dfiterrows-name-rowname-orig_id-rowid-count-rowgetcount-1-default-to-1-if-no-count-column-total_count-count-rep_name-rep_mapgetname-name-rep_id-rep_name_to_idgetrep_name-cluster_id-none-if-rep_id-rep_cluster_idx-rep_dfindexrep_dfid-rep_id-if-lenrep_cluster_idx-1-cluster_id-rep_dflocrep_cluster_idx0-cluster_id-if-cluster_id-1-cluster_rep_id-rep_id-noise_count-1-else-cluster_rep_id-cluster_rep_mapgetcluster_id-rep_id-row_data-id-orig_id-name-name-cluster_id-cluster_id-cluster_rep_id-cluster_rep_id-if-count-in-full_dfcolumns-row_datacount-count-rowsappendrow_data-result_df-pddataframerows-log-cluster-summary-num_clusters-lensetcluster_labels-1-if-1-in-cluster_labels-else-0-printf-mapping-complete-total-rows-total_count-total-count-printf-num_clusters-clusters-formed-printf-noise_count-items-marked-as-noise-singleton-clusters-optional-summary-of-total-count-per-cluster-rep-if-count-in-result_dfcolumns-cluster_summary-result_dfgroupbycluster_rep_idcount-sum-sort_valuesascendingfalse-printn-top-cluster-representatives-by-total-count-printcluster_summaryhead10-return-result_df-main-pipeline-function-def-full_deduplication_pipeline-all_names-liststr-full_df-pddataframe-minhash_threshold-float-08-num_perm-int-128-hdbscan_min_cluster_size-int-5-hdbscan_min_samples-int-none-epsilon_valuefloat-00-use_count_rep-bool-false-pddataframe-run-full-deduplication-pipeline-1-minhash-deduplication-on-names-2-load-embeddings-and-ids-from-chromadb-collections-this-wil-be-done-before-3-filter-embeddings-to-minhash-cluster-representatives-4-run-hdbscan-on-embeddings-of-representatives-5-assign-medoid-representatives-per-cluster-6-map-all-original-ids-to-cluster_id-and-cluster_rep_id-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-printrunning-minhash-deduplication-on-names-get-a-series-of-counts-for-minhash-clustering-representative-selection-if-count-in-full_dfcolumns-name_counts-full_dfgroupbynamecountsum-else-name_counts-pdseries1-indexfull_dfnameunique-clusters-minhash_clusterall_names-thresholdminhash_threshold-num_permnum_perm-rep_map-get_cluster_representativesclusters-name_counts-printffiltering-embeddings-to-lensetrep_mapvalues-cluster-representatives-rep_df-filter_to_representativesfull_df-rep_map-printrunning-hdbscan-on-representative-embeddings-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-cluster_labels-hdbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-epsilon_value-epsilon_value-cluster_labels-dbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-epsilon_value-epsilon_value-printbuilding-final-mapping-of-all-ids-to-cluster-ids-and-representative-ids-final_df-build_final_mappingfull_df-rep_df-rep_map-cluster_labels-use_count_repuse_count_rep-return-final_df-def-deduplication_pipeline_testing-all_names-liststr-full_df-pddataframe-rep_map-hdbscan_min_cluster_size-int-5-hdbscan_min_samples-int-none-pddataframe-run-full-deduplication-pipeline-1-minhash-deduplication-on-names-2-load-embeddings-and-ids-from-chromadb-collections-this-wil-be-done-before-3-filter-embeddings-to-minhash-cluster-representatives-4-run-hdbscan-on-embeddings-of-representatives-5-assign-medoid-representatives-per-cluster-6-map-all-original-ids-to-cluster_id-and-cluster_rep_id-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-printffiltering-embeddings-to-lensetrep_mapvalues-cluster-representatives-rep_df-filter_to_representativesfull_df-rep_map-printrunning-hdbscan-on-representative-embeddings-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-cluster_labels-hdbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-printbuilding-final-mapping-of-all-ids-to-cluster-ids-and-representative-ids-final_df-build_final_mappingfull_df-rep_df-rep_map-cluster_labels-return-final_df" class="md-nav__link">
    <span class="md-ellipsis">
      
        import pandas as pd import numpy as np from datasketch import MinHash, MinHashLSH from tqdm.auto import tqdm from cuml.cluster import HDBSCAN, DBSCAN from sklearn.metrics import pairwise_distances_argmin_min from sklearn.preprocessing import normalize # Import normalize import chromadb # ---------------------------------------- # Step 1: MinHash Deduplication on Names # ---------------------------------------- def get_minhash(text: str, num_perm: int = 128) -&gt; MinHash: m = MinHash(num_perm=num_perm) for token in set(text.lower().split()): m.update(token.encode(&#39;utf8&#39;)) return m def minhash_cluster(names: list[str], threshold: float = 0.8, num_perm: int = 128) -&gt; list[list[str]]: &quot;&quot;&quot; Cluster names by MinHash + LSH and return list of clusters (each a list of names). &quot;&quot;&quot; lsh = MinHashLSH(threshold=threshold, num_perm=num_perm) minhashes = {} print(&quot;Indexing names with MinHash...&quot;) for name in tqdm(names): mh = get_minhash(name, num_perm) lsh.insert(name, mh) minhashes[name] = mh print(&quot;Querying clusters from LSH...&quot;) visited = set() clusters = [] for name in tqdm(names): if name in visited: continue cluster = lsh.query(minhashes[name]) clusters.append(cluster) visited.update(cluster) return clusters def get_cluster_representatives(clusters: list[list[str]], name_counts: pd.Series) -&gt; dict[str, str]: &quot;&quot;&quot; Pick a representative name per cluster. The representative is chosen based on the highest count, or the shortest string if counts are equal or not available. Returns map: name -&gt; cluster_rep_name &quot;&quot;&quot; rep_map = {} for cluster in clusters: # Get counts for names in the current cluster cluster_counts = name_counts.reindex(cluster, fill_value=0) # Find the name with the maximum count # If there&#39;s a tie, min() will pick the one that comes first alphabetically, # but we want to break ties by shortest length. So we&#39;ll find max count first. max_count = cluster_counts.max() # Get all names with the maximum count candidates = cluster_counts[cluster_counts == max_count].index.tolist() # From the candidates, pick the one with the shortest length rep = min(candidates, key=len) for name in cluster: rep_map[name] = rep return rep_map # ---------------------------------------- # Step 2: Load Embeddings and IDs from ChromaDB # ---------------------------------------- # def load_all_embeddings(chroma_collection_names: list[str]) -&gt; pd.DataFrame: # &quot;&quot;&quot; # Fetch all embeddings + ids + names from multiple ChromaDB collections, combine into one DataFrame. # Returns DataFrame with columns: id, name, embedding (np.array) # &quot;&quot;&quot; # chroma_client = chromadb.HttpClient(host = &#39;34.71.102.215&#39;, port = 8000) # all_data = [] # for collection_name in chroma_collection_names: # collection = chroma_client.get_collection(collection_name) # results = collection.get(include=[&quot;embeddings&quot;, &#39;metadatas&#39;]) # # ids = unique IDs in collection # # embeddings = list of vectors # ids = results[&quot;ids&quot;] # embeddings = results[&quot;embeddings&quot;] # metadatas = results[&#39;metadatas&#39;] # df = pd.DataFrame({&quot;id&quot;: ids}) # df[&quot;embedding&quot;] = [e for e in embeddings] # df[&#39;name&#39;] = [meta[&#39;name&#39;] for meta in metadatas] # all_data.append(df) # full_df = pd.concat(all_data, ignore_index=True) # # Remove duplicate names keeping first appearance # full_df = full_df.drop_duplicates(subset=&quot;id&quot;).reset_index(drop=True) # return full_df def load_all_embeddings(name_df: pd.DataFrame, chroma_collection_names: list[str]) -&gt; pd.DataFrame: &quot;&quot;&quot; Fetch all embeddings + ids + names from multiple ChromaDB collections, combine into one DataFrame. Args: name_df: DataFrame containing &#39;id&#39; and &#39;name&#39; columns to match with embeddings chroma_collection_names: List of ChromaDB collection names to fetch embeddings from Returns: DataFrame with columns: id, name, embedding (np.array) &quot;&quot;&quot; chroma_client = chromadb.HttpClient(host=&#39;34.71.102.215&#39;, port=8000) # Create a dictionary to store embeddings by ID for faster lookup embeddings_dict = {} for collection_name in chroma_collection_names: try: collection = chroma_client.get_collection(collection_name) results = collection.get(include=[&quot;embeddings&quot;]) # Store each id and its corresponding embedding in the dictionary # for id_, embedding in zip(results[&quot;ids&quot;], results[&quot;embeddings&quot;]): for id_, embedding in zip(results[&quot;ids&quot;], normalize(results[&quot;embeddings&quot;], norm = &#39;l2&#39;)): embeddings_dict[id_] = np.array(embedding) except Exception as e: print(f&quot;Error loading collection {collection_name}: {str(e)}&quot;) continue # Create a new DataFrame with the same rows as name_df full_df = name_df.copy() # Add embeddings to the DataFrame full_df[&#39;embedding&#39;] = full_df[&#39;id&#39;].map(embeddings_dict) # Drop rows where no embedding was found (if desired) full_df = full_df.dropna(subset=[&#39;embedding&#39;]) return full_df # ---------------------------------------- # Step 3: Filter Embeddings to MinHash Cluster Representatives # ---------------------------------------- def filter_to_representatives(full_df: pd.DataFrame, rep_map: dict[str, str]) -&gt; pd.DataFrame: &quot;&quot;&quot; Filter full_df rows to only those whose name is a cluster representative. &quot;&quot;&quot; reps = set(rep_map.values()) filtered = full_df[full_df[&quot;name&quot;].isin(reps)].reset_index(drop=True) return filtered # ---------------------------------------- # Step 4: HDBSCAN Clustering on Embeddings # ---------------------------------------- def hdbscan_cluster_embeddings(embeddings: np.ndarray, min_cluster_size: int = 5, min_samples: int = None, epsilon_value: float = 0.0) -&gt; np.ndarray: &quot;&quot;&quot; Run cuML HDBSCAN clustering on embeddings array. &quot;&quot;&quot; clusterer = HDBSCAN(min_cluster_size=min_cluster_size, min_samples=min_samples, cluster_selection_epsilon = epsilon_value, metric = &#39;euclidean&#39;, verbose = 3 ) labels = clusterer.fit_predict(embeddings) return labels def dbscan_cluster_embeddings(embeddings: np.ndarray, min_cluster_size: int = 5, min_samples: int = None, epsilon_value: float = 0.0) -&gt; np.ndarray: &quot;&quot;&quot; Run cuML HDBSCAN clustering on embeddings array. &quot;&quot;&quot; clusterer = DBSCAN( # min_cluster_size=min_cluster_size, min_samples=min_samples, eps = epsilon_value, metric = &#39;cosine&#39;, verbose = 3 ) labels = clusterer.fit_predict(embeddings) return labels # ---------------------------------------- # Step 5: Assign Medoid as Cluster Representative ID # ---------------------------------------- def assign_medoid_representative(embeddings: np.ndarray, labels: np.ndarray, ids: list[str]) -&gt; dict[int, str]: &quot;&quot;&quot; For each cluster, find medoid (closest embedding to cluster centroid). Returns dict: cluster_label -&gt; medoid_id &quot;&quot;&quot; cluster_medoid = {} for cluster_label in set(labels): if cluster_label == -1: # Noise cluster: no medoid continue cluster_indices = np.where(labels == cluster_label)[0] cluster_embeds = embeddings[cluster_indices] # Compute centroid centroid = cluster_embeds.mean(axis=0).reshape(1, -1) # Find closest embedding to centroid (medoid) medoid_idx, _ = pairwise_distances_argmin_min(centroid, cluster_embeds) medoid_id = ids[cluster_indices[medoid_idx[0]]] cluster_medoid[cluster_label] = medoid_id return cluster_medoid def assign_count_based_representative(rep_df: pd.DataFrame, cluster_labels: np.ndarray) -&gt; dict[int, str]: &quot;&quot;&quot; For each cluster, find the representative with the highest count. If &#39;count&#39; column is not available, falls back to medoid logic. Returns dict: cluster_label -&gt; count_based_rep_id &quot;&quot;&quot; cluster_rep_ids = {} if &quot;count&quot; not in rep_df.columns: print(&quot;Warning: &#39;count&#39; column not found in representative DataFrame. Falling back to medoid-based representatives.&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].values).astype(np.float32) return assign_medoid_representative(embeddings_array, cluster_labels, rep_df[&quot;id&quot;].tolist()) for cluster_label in set(cluster_labels): if cluster_label == -1: continue cluster_rows = rep_df[cluster_labels == cluster_label] # Find the row with the maximum count # In case of a tie, `idxmax` will return the first occurrence, which is fine max_count_row = cluster_rows.loc[cluster_rows[&quot;count&quot;].idxmax()] cluster_rep_ids[cluster_label] = max_count_row[&quot;id&quot;] return cluster_rep_ids # ---------------------------------------- # Step 6: Build Final DataFrame with cluster_id and cluster_rep_id per original id # ---------------------------------------- def build_final_mapping( full_df: pd.DataFrame, rep_df: pd.DataFrame, rep_map: dict[str, str], cluster_labels: np.ndarray, use_count_rep: bool = False ) -&gt; pd.DataFrame: &quot;&quot;&quot; Assign cluster_id and cluster_rep_id for all original ids. Args: full_df: DataFrame with all original ids, names, embeddings, and optionally a &#39;count&#39; column. rep_df: DataFrame with representatives only, their embeddings and cluster labels. rep_map: map original name -&gt; representative name (string) cluster_labels: HDBSCAN cluster labels for rep_df rows. use_count_rep: If True, uses the highest-count item as cluster representative. Otherwise, uses the medoid. Returns: DataFrame with columns: id, name, cluster_id, cluster_rep_id, count (if present in input) &quot;&quot;&quot; rep_df = rep_df.copy() rep_df[&quot;cluster_id&quot;] = cluster_labels # Choose representative assignment method if use_count_rep and &quot;count&quot; in rep_df.columns: print(&quot;Assigning cluster representatives based on highest count...&quot;) cluster_rep_map = assign_count_based_representative(rep_df, cluster_labels) else: print(&quot;Assigning cluster representatives based on medoid (closest to centroid)...&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].tolist()) cluster_rep_map = assign_medoid_representative(embeddings_array, cluster_labels, rep_df[&quot;id&quot;].tolist()) # Map representative name to ID rep_name_to_id = dict(zip(rep_df[&quot;name&quot;], rep_df[&quot;id&quot;])) rows = [] noise_count = 0 total = len(full_df) total_count = 0 for _, row in full_df.iterrows(): name = row[&quot;name&quot;] orig_id = row[&quot;id&quot;] count = row.get(&quot;count&quot;, 1) # Default to 1 if no count column total_count += count rep_name = rep_map.get(name, name) rep_id = rep_name_to_id.get(rep_name) cluster_id = None if rep_id: rep_cluster_idx = rep_df.index[rep_df[&quot;id&quot;] == rep_id] if len(rep_cluster_idx) == 1: cluster_id = rep_df.loc[rep_cluster_idx[0], &quot;cluster_id&quot;] if cluster_id == -1: cluster_rep_id = rep_id noise_count += 1 else: cluster_rep_id = cluster_rep_map.get(cluster_id, rep_id) row_data = { &quot;id&quot;: orig_id, &quot;name&quot;: name, &quot;cluster_id&quot;: cluster_id, &quot;cluster_rep_id&quot;: cluster_rep_id, } if &quot;count&quot; in full_df.columns: row_data[&quot;count&quot;] = count rows.append(row_data) result_df = pd.DataFrame(rows) # Log cluster summary num_clusters = len(set(cluster_labels)) - (1 if -1 in cluster_labels else 0) print(f&quot;‚úÖ Mapping complete: {total} rows, {total_count} total count&quot;) print(f&quot;üì¶ {num_clusters} clusters formed&quot;) print(f&quot;üå™Ô∏è {noise_count} items marked as noise (singleton clusters)&quot;) # Optional: Summary of total count per cluster rep if &quot;count&quot; in result_df.columns: cluster_summary = ( result_df.groupby(&quot;cluster_rep_id&quot;)[&quot;count&quot;] .sum() .sort_values(ascending=False) ) print(&quot;\nüî¢ Top cluster representatives by total count:&quot;) print(cluster_summary.head(10)) return result_df # ---------------------------------------- # Main pipeline function # ---------------------------------------- def full_deduplication_pipeline( all_names: list[str], full_df: pd.DataFrame, minhash_threshold: float = 0.8, num_perm: int = 128, hdbscan_min_cluster_size: int = 5, hdbscan_min_samples: int = None, epsilon_value:float = 0.0, use_count_rep: bool = False ) -&gt; pd.DataFrame: &quot;&quot;&quot; Run full deduplication pipeline: 1. MinHash deduplication on names 2. Load embeddings and IDs from ChromaDB collections -- this wil be done before 3. Filter embeddings to MinHash cluster representatives 4. Run HDBSCAN on embeddings of representatives 5. Assign medoid representatives per cluster 6. Map all original ids to cluster_id and cluster_rep_id Returns: DataFrame with columns: id, name, cluster_id, cluster_rep_id &quot;&quot;&quot; print(&quot;Running MinHash deduplication on names...&quot;) # Get a Series of counts for MinHash clustering representative selection if &quot;count&quot; in full_df.columns: name_counts = full_df.groupby(&quot;name&quot;)[&quot;count&quot;].sum() else: name_counts = pd.Series(1, index=full_df[&quot;name&quot;].unique()) clusters = minhash_cluster(all_names, threshold=minhash_threshold, num_perm=num_perm) rep_map = get_cluster_representatives(clusters, name_counts) print(f&quot;Filtering embeddings to {len(set(rep_map.values()))} cluster representatives...&quot;) rep_df = filter_to_representatives(full_df, rep_map) print(&quot;Running HDBSCAN on representative embeddings...&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].values).astype(np.float32) cluster_labels = hdbscan_cluster_embeddings( embeddings_array, min_cluster_size=hdbscan_min_cluster_size, min_samples=hdbscan_min_samples, epsilon_value = epsilon_value ) # cluster_labels = dbscan_cluster_embeddings( # embeddings_array, # min_cluster_size=hdbscan_min_cluster_size, # min_samples=hdbscan_min_samples, # epsilon_value = epsilon_value # ) print(&quot;Building final mapping of all IDs to cluster IDs and representative IDs...&quot;) final_df = build_final_mapping(full_df, rep_df, rep_map, cluster_labels, use_count_rep=use_count_rep) return final_df def deduplication_pipeline_testing( all_names: list[str], full_df: pd.DataFrame, rep_map, hdbscan_min_cluster_size: int = 5, hdbscan_min_samples: int = None, ) -&gt; pd.DataFrame: &quot;&quot;&quot; Run full deduplication pipeline: 1. MinHash deduplication on names 2. Load embeddings and IDs from ChromaDB collections -- this wil be done before 3. Filter embeddings to MinHash cluster representatives 4. Run HDBSCAN on embeddings of representatives 5. Assign medoid representatives per cluster 6. Map all original ids to cluster_id and cluster_rep_id Returns: DataFrame with columns: id, name, cluster_id, cluster_rep_id &quot;&quot;&quot; print(f&quot;Filtering embeddings to {len(set(rep_map.values()))} cluster representatives...&quot;) rep_df = filter_to_representatives(full_df, rep_map) print(&quot;Running HDBSCAN on representative embeddings...&quot;) embeddings_array = np.vstack(rep_df[&quot;embedding&quot;].values).astype(np.float32) cluster_labels = hdbscan_cluster_embeddings( embeddings_array, min_cluster_size=hdbscan_min_cluster_size, min_samples=hdbscan_min_samples ) print(&quot;Building final mapping of all IDs to cluster IDs and representative IDs...&quot;) final_df = build_final_mapping(full_df, rep_df, rep_map, cluster_labels) return final_df
      
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-workdna-ontology-service" class="md-nav__link">
    <span class="md-ellipsis">
      
        4. WorkDNA Ontology Service
      
    </span>
  </a>
  
    <nav class="md-nav" aria-label="4. WorkDNA Ontology Service">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41-structure-of-the-ontology" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1 Structure of the Ontology
      
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#41-purpose" class="md-nav__link">
    <span class="md-ellipsis">
      
        4.1 Purpose
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="work-dna-ai"><strong>WORK DNA AI</strong></h1>
<h2 id="1-overview">1. Overview</h2>
<p>This document explains the logic behind the <strong>WorkDNA AI</strong> for the Karrera App.<br />
It describes how the ontology was created, how capabilities are collected, cleaned, and classified, and how these outputs are used to generate a <strong>Work DNA</strong> for users.  </p>
<p>Our objective is not only to build a final capability table or a static ontology ‚Äî<br />
it is to <strong>use the ontology as the foundation</strong> for extracting capabilities from a user‚Äôs Professional Identity and generating a personalized <strong>WorkDNA profile</strong>.  </p>
<p>This involves:  </p>
<ul>
<li><strong>Defining the ontology</strong>: The WorkDNA Ontology is a structured knowledge graph of 312 capability nodes, each representing a distinct skill or competency, organized into seven major capability types.  </li>
<li><strong>Ingesting raw capabilities</strong>: Pulling capabilities from CSVs, resumes, or embedding databases (ChromaDB) with associated descriptions and metadata.  </li>
<li><strong>Deduplicating capabilities</strong>: Using both <strong>MinHash</strong> (text similarity) and <strong>HDBSCAN</strong> (semantic similarity) to merge duplicates and near-duplicates.  </li>
<li><strong>Classifying capabilities</strong>: Running each deduplicated capability through trained neural networks to assign the most likely WorkDNA node(s).  </li>
<li><strong>Building the capability table</strong>: Producing a clean, enriched table with capability names, descriptions, predicted ontology nodes, and metadata for downstream use.  </li>
<li><strong>Generating WorkDNA profiles</strong>: Aggregating mapped capabilities into a structured Professional Identity that aligns with the ontology and can be compared, analyzed, and recommended within the Karrera ecosystem.  </li>
</ul>
<p>The methods described here are designed to:<br />
1. <strong>Ensure data quality</strong> by removing duplicates and inconsistencies.<br />
2. <strong>Leverage AI models</strong> for accurate capability-to-ontology mapping.<br />
3. <strong>Translate raw user data</strong> into a meaningful Professional Identity.<br />
4. <strong>Support scalability</strong> for datasets containing hundreds of thousands of capabilities.<br />
5. <strong>Integrate seamlessly</strong> with the Karrera App for user-facing recommendations, career paths, and insights.</p>
<h2 id="2-ontology-creation">2. Ontology Creation</h2>
<h3 id="purpose">Purpose</h3>
<p>The <strong>WorkDNA Ontology</strong> serves as the backbone of the entire capability mapping process.<br />
It defines a structured network of <strong>capability nodes</strong>, grouped into <strong>seven major capability types</strong>, and enriched with descriptions, relationships, and identifiers.  </p>
<p>This ontology is used to:
- Standardize capability definitions across datasets.
- Provide a <strong>common language</strong> for AI classification outputs.
- Enable structured Professional Identity generation for users.</p>
<hr />
<h3 id="structure">Structure</h3>
<ul>
<li><strong>File format</strong>: Turtle (<code>.ttl</code>)</li>
<li><strong>Content</strong>:</li>
<li><strong>Nodes</strong>: 312 unique capability nodes.<ul>
<li>Each node has:</li>
<li>A unique ID (e.g., <code>K101a01</code>)</li>
<li>A descriptive definition</li>
<li>A capability type (one of seven types: Ability, Activity, Attribute, Context, Knowledge, Motivation, Skill)</li>
</ul>
</li>
<li><strong>Edges</strong>: (Optional for current scope) Hierarchical and associative relationships between nodes.</li>
</ul>
<p>Example (simplified):</p>
<div class="language-ttl highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="o">&lt;</span>#<span class="nv">K101a01</span><span class="o">&gt;</span><span class="w"> </span>#<span class="w"> </span><span class="nv">Information</span><span class="w"> </span><span class="nv">Ordering</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="w">    </span><span class="nv">a</span><span class="w"> </span><span class="nv">schema</span>:<span class="nv">DefinedTerm</span><span class="w"> </span><span class="c1">;</span>
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="w">    </span><span class="nv">schema</span>:<span class="nv">termCode</span><span class="w"> </span><span class="s2">&quot;K101a01&quot;</span><span class="w"> </span><span class="c1">;</span>
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="w">    </span><span class="nv">schema</span>:<span class="nv">name</span><span class="w"> </span><span class="s2">&quot;Information Ordering&quot;</span><span class="w"> </span><span class="c1">;</span>
</span><span id="__span-0-5"><a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a><span class="w">    </span><span class="nv">schema</span>:<span class="nv">description</span><span class="w"> </span><span class="s2">&quot;The ability to arrange things or actions in a certain order or pattern according to a specific rule or set of rules (e.g., patterns of numbers, letters, words, pictures, mathematical operations).&quot;</span><span class="w"> </span><span class="c1">;</span>
</span><span id="__span-0-6"><a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a><span class="w">    </span><span class="nv">schema</span>:<span class="nv">bestRating</span><span class="w"> </span><span class="s2">&quot;5&quot;</span>.
</span></code></pre></div>
<h3 id="loading-the-ontology">Loading the Ontology</h3>
<p>The ontology is loaded into memory using the <strong><code>WorkDNAOntologyService</code></strong> class. We will discuss later the purposes of the class</p>
<h4 id="responsibilities-of-workdnaprocessorservice">Responsibilities of <code>WorkDNAProcessorService</code>:</h4>
<ul>
<li>
<p><strong>Read and parse the <code>.ttl</code> ontology file</strong><br />
  Uses <code>rdflib.Graph</code> to load the ontology and extract node information.</p>
</li>
<li>
<p><strong>Store ontology in a structured form</strong><br />
  Ontology nodes are stored in a Python dictionary keyed by node ID, with their descriptions and types:  </p>
</li>
<li>
<p><strong>Provide helper methods for querying and mapping ontology data.</strong> 
    We will also discuss these methods after</p>
</li>
</ul>
<h5 id="data-structure-example">Data Structure Example</h5>
<div class="language-python highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="p">{</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>  <span class="s2">&quot;K101a01&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ability&quot;</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>  <span class="p">}</span>
</span><span id="__span-1-6"><a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a><span class="p">}</span>
</span></code></pre></div>
<h3 id="role-in-the-pipeline">Role in the Pipeline</h3>
<p>The ontology is not just a static reference ‚Äî it plays an active role in:</p>
<ul>
<li>
<p><strong>Mapping raw model outputs (node IDs) into meaningful descriptions.</strong></p>
</li>
<li>
<p><strong>Enforcing consistency across classification and profile generation.</strong></p>
</li>
<li>
<p><strong>Serving as the backbone for WorkDNA profile construction.</strong></p>
</li>
</ul>
<h2 id="3-capability-table-creation-deduplication">3. Capability Table Creation &amp; Deduplication</h2>
<h3 id="31-introduction">3.1: Introduction</h3>
<p>Before the ontology can be used to generate WorkDNA profiles, we first need to <strong>create a capability table</strong>. The point of this capability is to extend the <strong>WorkDNA</strong> so that we can know to what node a certain skill points to. This creation stage is critical because raw capability data is often <strong><em>messy, redundant, and inconsistent</em></strong>. Without preprocessing, mapping capabilities to ontology nodes would be unreliable and inaccurate.</p>
<p>The process is divided into three main components:
1. <strong>Capability Dataset Construction</strong> ‚Äì assembling raw capabilities from source databases into a unified dataset.
2. <strong>Embedding Creation</strong> ‚Äì generating high-dimensional vector representations of capability names and descriptions.
3. <strong>Deduplication and Clustering</strong> ‚Äì removing redundant or near-duplicate capabilities using a hybrid approach that combines <strong>MinHash similarity detection</strong> and <strong>embedding-based clustering with HDBSCAN</strong>.</p>
<p>The outcome of this stage is a curated set of unique capabilities that serve as the input for ontology alignment and downstream WorkDNA profile construction.</p>
<h3 id="32-capability-dataset-creation">3.2 Capability Dataset Creation</h3>
<p>The raw input to our pipeline consists of large datasets of <strong>capabilities (skills, attributes, activities, etc.)</strong> extracted from external sources. Each capability typically has:</p>
<ul>
<li><strong>A name:</strong> short label such as <code>"Python"</code>, <code>"Team Leadership"</code>, or <code>"Strategic Thinking"</code></li>
<li><strong>A description:</strong> longer explanatory text when available, e.g., <code>"The ability to design and implement solutions in Python programming language.</code>"</li>
<li><strong>A type:</strong> one of the seven WorkDNA categories (<code>skill</code>, <code>attribute</code>, <code>context</code>, <code>knowledge</code>, <code>ability</code>, <code>motivation</code>, <code>activity</code>).</li>
</ul>
<p>Because different sources may describe the same capability differently (e.g., <code>"Python"</code> vs. <code>"Python Programming"</code> vs. <code>"Python scripting"</code>), we cannot assume names are clean or unique.</p>
<p>The dataset creation process includes:</p>
<ol>
<li>
<p><strong>Extracting raw capabilities using GEMINI AI</strong> from WorkDNA Nodes and our Occupations database.</p>
<ol>
<li><strong>Creating a prompt for the AI to generate content</strong>, like the example below: 
<div class="language-python highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="k">def</span><span class="w"> </span><span class="nf">generate_ability_prompt</span><span class="p">(</span><span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node_description</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num_examples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">existing_capabilities</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parent_nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span><span id="__span-2-2"><a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-2-3"><a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="sd">Generates a prompt string for the Gemini-Flash 2.0 model to create new &#39;Ability&#39; capabilities.</span>
</span><span id="__span-2-4"><a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>
</span><span id="__span-2-5"><a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a><span class="sd">This function constructs a detailed prompt that guides the model to generate a specified</span>
</span><span id="__span-2-6"><a id="__codelineno-2-6" name="__codelineno-2-6" href="#__codelineno-2-6"></a><span class="sd">number of diverse, specific, and distinct abilities. It includes the work DNA node&#39;s</span>
</span><span id="__span-2-7"><a id="__codelineno-2-7" name="__codelineno-2-7" href="#__codelineno-2-7"></a><span class="sd">name and description, specifies the desired output format (JSON), and provides a list</span>
</span><span id="__span-2-8"><a id="__codelineno-2-8" name="__codelineno-2-8" href="#__codelineno-2-8"></a><span class="sd">of existing capabilities to avoid generating duplicates.</span>
</span><span id="__span-2-9"><a id="__codelineno-2-9" name="__codelineno-2-9" href="#__codelineno-2-9"></a>
</span><span id="__span-2-10"><a id="__codelineno-2-10" name="__codelineno-2-10" href="#__codelineno-2-10"></a><span class="sd">Args:</span>
</span><span id="__span-2-11"><a id="__codelineno-2-11" name="__codelineno-2-11" href="#__codelineno-2-11"></a><span class="sd">    node_name (str): The name of the work_dna_node (e.g., &quot;Problem Solving&quot;).</span>
</span><span id="__span-2-12"><a id="__codelineno-2-12" name="__codelineno-2-12" href="#__codelineno-2-12"></a><span class="sd">    node_description (str): The definition or description of the work_dna_node,</span>
</span><span id="__span-2-13"><a id="__codelineno-2-13" name="__codelineno-2-13" href="#__codelineno-2-13"></a><span class="sd">                            specifically related to an &#39;Ability&#39;.</span>
</span><span id="__span-2-14"><a id="__codelineno-2-14" name="__codelineno-2-14" href="#__codelineno-2-14"></a><span class="sd">    num_examples (int): The desired number of ability examples to generate.</span>
</span><span id="__span-2-15"><a id="__codelineno-2-15" name="__codelineno-2-15" href="#__codelineno-2-15"></a><span class="sd">    existing_capabilities (list[str]): A list of previously generated ability names</span>
</span><span id="__span-2-16"><a id="__codelineno-2-16" name="__codelineno-2-16" href="#__codelineno-2-16"></a><span class="sd">                                       that the model should avoid duplicating. If</span>
</span><span id="__span-2-17"><a id="__codelineno-2-17" name="__codelineno-2-17" href="#__codelineno-2-17"></a><span class="sd">                                       empty, no exclusion clause is added.</span>
</span><span id="__span-2-18"><a id="__codelineno-2-18" name="__codelineno-2-18" href="#__codelineno-2-18"></a><span class="sd">    parent_nodes (list[str]): A list of parent node names for the current work_dna_node,</span>
</span><span id="__span-2-19"><a id="__codelineno-2-19" name="__codelineno-2-19" href="#__codelineno-2-19"></a><span class="sd">                              ordered from immediate parent to highest ancestor.</span>
</span><span id="__span-2-20"><a id="__codelineno-2-20" name="__codelineno-2-20" href="#__codelineno-2-20"></a>
</span><span id="__span-2-21"><a id="__codelineno-2-21" name="__codelineno-2-21" href="#__codelineno-2-21"></a><span class="sd">Returns:</span>
</span><span id="__span-2-22"><a id="__codelineno-2-22" name="__codelineno-2-22" href="#__codelineno-2-22"></a><span class="sd">    str: A formatted string representing the prompt for the Gemini-Flash 2.0 model.</span>
</span><span id="__span-2-23"><a id="__codelineno-2-23" name="__codelineno-2-23" href="#__codelineno-2-23"></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-2-24"><a id="__codelineno-2-24" name="__codelineno-2-24" href="#__codelineno-2-24"></a><span class="n">existing_capabilities_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Ensure these new abilities are distinct from the following: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">existing_capabilities</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span> <span class="k">if</span> <span class="n">existing_capabilities</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
</span><span id="__span-2-25"><a id="__codelineno-2-25" name="__codelineno-2-25" href="#__codelineno-2-25"></a>
</span><span id="__span-2-26"><a id="__codelineno-2-26" name="__codelineno-2-26" href="#__codelineno-2-26"></a><span class="n">parent_info_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
</span><span id="__span-2-27"><a id="__codelineno-2-27" name="__codelineno-2-27" href="#__codelineno-2-27"></a><span class="k">if</span> <span class="n">parent_nodes</span><span class="p">:</span>
</span><span id="__span-2-28"><a id="__codelineno-2-28" name="__codelineno-2-28" href="#__codelineno-2-28"></a>    <span class="n">parent_info_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; This node is part of the following taxonomy hierarchy: </span><span class="si">{</span><span class="w"> </span><span class="s1">&#39; -&gt; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent_nodes</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2">.&quot;</span>
</span><span id="__span-2-29"><a id="__codelineno-2-29" name="__codelineno-2-29" href="#__codelineno-2-29"></a>
</span><span id="__span-2-30"><a id="__codelineno-2-30" name="__codelineno-2-30" href="#__codelineno-2-30"></a><span class="n">prompt</span> <span class="o">=</span> <span class="p">(</span>
</span><span id="__span-2-31"><a id="__codelineno-2-31" name="__codelineno-2-31" href="#__codelineno-2-31"></a>    <span class="sa">f</span><span class="s1">&#39;&#39;&#39;Given the work DNA node &quot;</span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1">&quot; focused on &quot;Ability&quot;, defined as &quot;</span><span class="si">{</span><span class="n">node_description</span><span class="si">}</span><span class="s1">&quot;.</span>
</span><span id="__span-2-32"><a id="__codelineno-2-32" name="__codelineno-2-32" href="#__codelineno-2-32"></a><span class="s1">    Generate exactly </span><span class="si">{</span><span class="n">num_examples</span><span class="si">}</span><span class="s1"> diverse, specific, and distinct **abilities** (enduring individual attributes influencing performance) that a person might possess and apply in various occupations, directly related to and falling under the &quot;</span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1">&quot; node.</span>
</span><span id="__span-2-33"><a id="__codelineno-2-33" name="__codelineno-2-33" href="#__codelineno-2-33"></a><span class="s1">    </span><span class="si">{</span><span class="n">parent_info_str</span><span class="si">}</span>
</span><span id="__span-2-34"><a id="__codelineno-2-34" name="__codelineno-2-34" href="#__codelineno-2-34"></a>
</span><span id="__span-2-35"><a id="__codelineno-2-35" name="__codelineno-2-35" href="#__codelineno-2-35"></a><span class="s1">    For each ability, provide:</span>
</span><span id="__span-2-36"><a id="__codelineno-2-36" name="__codelineno-2-36" href="#__codelineno-2-36"></a><span class="s1">    1.  A concise `name` (e.g., &quot;Critical Thinking&quot;).</span>
</span><span id="__span-2-37"><a id="__codelineno-2-37" name="__codelineno-2-37" href="#__codelineno-2-37"></a><span class="s1">    2.  A clear and specific `description` explaining what the ability entails and how it influences performance.</span>
</span><span id="__span-2-38"><a id="__codelineno-2-38" name="__codelineno-2-38" href="#__codelineno-2-38"></a><span class="s1">    3.  An `importance` score (an integer from 1 to 10), indicating how crucial this ability is for someone proficient in &quot;</span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1">&quot; to perform effectively (10 being very important).</span>
</span><span id="__span-2-39"><a id="__codelineno-2-39" name="__codelineno-2-39" href="#__codelineno-2-39"></a>
</span><span id="__span-2-40"><a id="__codelineno-2-40" name="__codelineno-2-40" href="#__codelineno-2-40"></a><span class="s1">    </span><span class="si">{</span><span class="n">existing_capabilities_str</span><span class="si">}</span>
</span><span id="__span-2-41"><a id="__codelineno-2-41" name="__codelineno-2-41" href="#__codelineno-2-41"></a>
</span><span id="__span-2-42"><a id="__codelineno-2-42" name="__codelineno-2-42" href="#__codelineno-2-42"></a><span class="s1">    Output the result as a JSON array of objects, where each object has &quot;name&quot;, &quot;description&quot;, and &quot;importance&quot; keys. Do NOT include any additional text or formatting outside the JSON array.</span>
</span><span id="__span-2-43"><a id="__codelineno-2-43" name="__codelineno-2-43" href="#__codelineno-2-43"></a><span class="s1">    &#39;&#39;&#39;</span>
</span><span id="__span-2-44"><a id="__codelineno-2-44" name="__codelineno-2-44" href="#__codelineno-2-44"></a><span class="p">)</span>
</span><span id="__span-2-45"><a id="__codelineno-2-45" name="__codelineno-2-45" href="#__codelineno-2-45"></a><span class="k">return</span> <span class="n">prompt</span>
</span></code></pre></div></li>
<li><strong>Running the process</strong> at least 8 times for each WorkDNA node, only once per occupation (20,000+ occupations)</li>
</ol>
</li>
<li>
<p><strong>Normalizing text</strong> (lowercasing, trimming whitespace, removing punctuation, lemmatizing when appropriate).</p>
</li>
<li><strong>Storing the results in a table</strong>, with the columns: <code>name</code>, <code>type</code>, <code>description</code>, <code>importance</code> (not very relevant), <code>node_reference</code> or <code>occupation_reference</code>, like shown in the json sructure below
<div class="language-json highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="p">{</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="w">  </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;python programming&quot;</span><span class="p">,</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="w">  </span><span class="nt">&quot;description&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;The capability to design and implement solutions using the Python programming language.&quot;</span><span class="p">,</span>
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="w">  </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;skill&quot;</span><span class="p">,</span>
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="w">  </span><span class="nt">&quot;node_reference&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;K403a10&quot;</span><span class="p">,</span>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="w">  </span><span class="nt">&quot;importance&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span>
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="p">}</span>
</span></code></pre></div></li>
</ol>
<p>At the end, we would have <strong>two big tables</strong>: <code>workDNA_extension.csv</code> and <code>occupations_extension.csv</code>, with a total of more than 1,300,000 capabilities. This provides a unified structure for downstream processing.</p>
<h3 id="33-embedding-creation">3.3 Embedding Creation</h3>
<p>Once the dataset is normalized, we generate <strong>dense vector embeddings</strong> for each capability. These embeddings are crucial for semantic comparison and clustering.
* We use a <strong>sentence transformer model</strong> (we first started with <code>all-mpnet-base-v2</code> but then improved to use <code>Qwen/Qwen3-Embedding-0.6B</code>, which is a state-of-the-art model with a great combination of effieciency and performance) to encode both capability names, types and descriptions into 1024-dimensional vectors.
    * First, we would <strong>clean the description</strong>, by removing trailing whitespaces, quote marks ("), and dots (.), and removing any unnecessary texts.
    * Second, we would get the <strong>name, type and clean description</strong> and use <code>.lower()</code> on all of them.
    * Third, we would encode the text like this:
    <div class="language-python highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a> <span class="n">embedding</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">): </span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
</span></code></pre></div>
* The embeddings are stored in a <strong>ChromaDB vector database</strong>, enabling fast similarity queries and clustering.</p>
<p>This embedding layer forms the semantic backbone of the deduplication pipeline. By comparing vector distances, we can identify capabilities that are semantically similar, even when their names differ significantly (e.g., <strong><em>‚ÄúProject Coordination‚Äù</em></strong> vs <strong><em>‚ÄúManaging Projects‚Äù</em></strong>).</p>
<h3 id="34-deduplication-process">3.4 Deduplication Process</h3>
<p>The deduplication process is performed in <strong>three major stages</strong>:</p>
<h4 id="341-selecting-unique-names-and-rewriting-descriptions-in-an-standardized-way">3.4.1 <strong>Selecting Unique Names and rewriting descriptions in an standardized way</strong></h4>
<ul>
<li>On a first go, the descriptions were not very good -- many of them described specific aspects of the name in specific situations.</li>
<li>Since some cpabilities appeared more than once in different scenarios, they had different descriptions.</li>
<li>The best approach we found was to rewrite the descriptions using <code>gemini-flash-2.0</code> and having <code>temperature = 0</code> as a parameter.</li>
<li>This way, we already reduced the number of capabilities from <strong>1.3M</strong> to <strong>240K</strong>.</li>
</ul>
<h4 id="342-minhash-based-similarity-clustering">3.4.2 <strong>MinHash-Based Similarity Clustering</strong></h4>
<p>Even with embeddings, we need to handle <strong>textual duplicates</strong> that differ slightly in wording. So, the first stage uses <strong>MinHashing</strong>, a probabilistic technique for estimating text similarity. This is especially efficient for large-scale datasets because it avoids full pairwise comparisons.
* <strong>Shingling</strong>: Each capability name was broken into character-level n-grams.
* <strong>MinHash Signatures</strong>: A compact signature was generated for each capability.
* <strong>Similarity Estimation</strong>: Capabilities with signatures exceeding a predefined <strong>Jaccard similarity threshold</strong> (default is <strong>0.8</strong>, but I tested with a lot of different values and liked the <strong>0.85-0.88</strong> range) were flagged as potential duplicates</p>
<p>We tested different strategies for selecting a representative:
- <strong>Shortest string</strong> in the cluster (e.g., "Python" instead of "Python Programming Language").
- <strong>Most frequent variant</strong> across the dataset, based on count (useful when integrating from multiple sources).</p>
<p>This step drastically reduced the candidate space, eliminating trivial duplicates while preserving semantically distinct entries. Here, we reduced <strong>hundreds of thousands of raw entries</strong> into a more manageable set of <strong>unique capability names</strong>. </p>
<h4 id="343-embedding-based-semantic-clustering-with-hdbscan">3.4.3 <strong>Embedding-Based Semantic Clustering with HDBSCAN</strong></h4>
<p>While MinHash handles near-identical strings, embeddings allow us to group <strong>semantically related capabilities</strong> that might not look alike textually. For example, <code>"software development"</code> and <code>"application engineering"</code> should cluster together.</p>
<ul>
<li><strong>Clustering Algorithm</strong>: <strong>HDBSCAN</strong> (Hierarchical Density-Based Spatial Clustering of Applications with Noise) was applied directly to the embeddings.<ul>
<li>We used <strong>HDBSCAN</strong> from the <strong>CuML</strong> library, since we were running this process on GPU to save hundreds of hours.</li>
</ul>
</li>
<li><strong>Parameters</strong>: Key hyperparameters include <code>min_cluster_size</code> and <code>min_samples</code>, which were tuned experimentally to balance <strong>cluster granularity</strong> (avoiding overly broad clusters) and <strong>noise detection</strong> (isolating capabilities with unique meanings).</li>
<li><strong>Semantic Grouping</strong>: Capabilities with high embedding similarity were grouped together, even if their textual representatives diverged.<ul>
<li>Again, we select a <strong>representative capability</strong> per cluster (using the frequency-based or medoid representative rule).</li>
<li>In more recent versions, we plan to use <strong>AI</strong> or a <strong>generalization score</strong> to define the cluster names.
Example: <strong><em>‚ÄúData Visualization‚Äù, ‚ÄúCreating Charts‚Äù,</em></strong> and <strong><em>‚ÄúData Presentation‚Äù</em></strong> would all be clustered together despite lexical differences.</li>
</ul>
</li>
</ul>
<p>We also ran this process a couple of times, to reduce even more the number of redundant capabilities.</p>
<p>This three-stage approach balances <strong>speed and textually cleaness(via MinHash)</strong> with <strong>semantic precision (via embeddings + clustering)</strong>.</p>
<h3 id="35-outputs-of-deduplication-final-capability-table">3.5 Outputs of Deduplication = FINAL CAPABILITY TABLE</h3>
<p>After deduplication and clustering, we build the final capability table, which serves as the input to the ontology mapping step. Each row contains:
- <code>name</code>: the representative string for the capability.
- <code>description</code>: cleaned description.
- <code>type</code>: one of the seven WorkDNA categories.
- <code>id</code>: (we used integers starting at 1) unique identifier of the representative.
- <code>version</code>: (if applicable) the version of the capability table</p>
<p>This table is now <strong>clean, deduplicated, and semantically organized</strong>, ready for integration with the <strong>WorkDNA Ontology Service.</strong></p>
<h3 id="36-role-in-the-workdna-pipeline">3.6 Role in the WorkDNA Pipeline</h3>
<p>This deduplication step is foundational for all subsequent stages:
- <strong>Ontology Mapping</strong>: Clean capabilities can be reliably mapped to WorkDNA nodes without duplication errors.
- <strong>Model Training</strong>: The reduced dataset provides higher-quality training samples for WorkDNA node classifiers.
- <strong>Profile Building</strong>: Deduplication ensures that user or organizational profiles are not inflated by repeated or redundant capabilities.</p>
<p>In short, this stage transforms messy raw data into a <strong>structured, semantically consistent capability set</strong>, ready to be aligned with the WorkDNA ontology.</p>
<p>With a deduplicated capability dataset in place, the next step is to connect these capabilities to the <strong>WorkDNA Ontology</strong>. This is where the <code>WorkDNAOntologyService</code> class comes into play, providing the mechanisms to load the ontology, perform fast lookups, and map capabilities into human-readable descriptions.</p>
<h3 id="before-talking-about-the-ontology-integration-here-is-the-code-used-for-the-deduplication-process">Before talking about the Ontology Integration, here is the code used for the deduplication process</h3>
<h2 id="import-pandas-as-pd-import-numpy-as-np-from-datasketch-import-minhash-minhashlsh-from-tqdmauto-import-tqdm-from-cumlcluster-import-hdbscan-dbscan-from-sklearnmetrics-import-pairwise_distances_argmin_min-from-sklearnpreprocessing-import-normalize-import-normalize-import-chromadb-step-1-minhash-deduplication-on-names-def-get_minhashtext-str-num_perm-int-128-minhash-m-minhashnum_permnum_perm-for-token-in-settextlowersplit-mupdatetokenencodeutf8-return-m-def-minhash_clusternames-liststr-threshold-float-08-num_perm-int-128-listliststr-cluster-names-by-minhash-lsh-and-return-list-of-clusters-each-a-list-of-names-lsh-minhashlshthresholdthreshold-num_permnum_perm-minhashes-printindexing-names-with-minhash-for-name-in-tqdmnames-mh-get_minhashname-num_perm-lshinsertname-mh-minhashesname-mh-printquerying-clusters-from-lsh-visited-set-clusters-for-name-in-tqdmnames-if-name-in-visited-continue-cluster-lshqueryminhashesname-clustersappendcluster-visitedupdatecluster-return-clusters-def-get_cluster_representativesclusters-listliststr-name_counts-pdseries-dictstr-str-pick-a-representative-name-per-cluster-the-representative-is-chosen-based-on-the-highest-count-or-the-shortest-string-if-counts-are-equal-or-not-available-returns-map-name-cluster_rep_name-rep_map-for-cluster-in-clusters-get-counts-for-names-in-the-current-cluster-cluster_counts-name_countsreindexcluster-fill_value0-find-the-name-with-the-maximum-count-if-theres-a-tie-min-will-pick-the-one-that-comes-first-alphabetically-but-we-want-to-break-ties-by-shortest-length-so-well-find-max-count-first-max_count-cluster_countsmax-get-all-names-with-the-maximum-count-candidates-cluster_countscluster_counts-max_countindextolist-from-the-candidates-pick-the-one-with-the-shortest-length-rep-mincandidates-keylen-for-name-in-cluster-rep_mapname-rep-return-rep_map-step-2-load-embeddings-and-ids-from-chromadb-def-load_all_embeddingschroma_collection_names-liststr-pddataframe-fetch-all-embeddings-ids-names-from-multiple-chromadb-collections-combine-into-one-dataframe-returns-dataframe-with-columns-id-name-embedding-nparray-chroma_client-chromadbhttpclienthost-3471102215-port-8000-all_data-for-collection_name-in-chroma_collection_names-collection-chroma_clientget_collectioncollection_name-results-collectiongetincludeembeddings-metadatas-ids-unique-ids-in-collection-embeddings-list-of-vectors-ids-resultsids-embeddings-resultsembeddings-metadatas-resultsmetadatas-df-pddataframeid-ids-dfembedding-e-for-e-in-embeddings-dfname-metaname-for-meta-in-metadatas-all_dataappenddf-full_df-pdconcatall_data-ignore_indextrue-remove-duplicate-names-keeping-first-appearance-full_df-full_dfdrop_duplicatessubsetidreset_indexdroptrue-return-full_df-def-load_all_embeddingsname_df-pddataframe-chroma_collection_names-liststr-pddataframe-fetch-all-embeddings-ids-names-from-multiple-chromadb-collections-combine-into-one-dataframe-args-name_df-dataframe-containing-id-and-name-columns-to-match-with-embeddings-chroma_collection_names-list-of-chromadb-collection-names-to-fetch-embeddings-from-returns-dataframe-with-columns-id-name-embedding-nparray-chroma_client-chromadbhttpclienthost3471102215-port8000-create-a-dictionary-to-store-embeddings-by-id-for-faster-lookup-embeddings_dict-for-collection_name-in-chroma_collection_names-try-collection-chroma_clientget_collectioncollection_name-results-collectiongetincludeembeddings-store-each-id-and-its-corresponding-embedding-in-the-dictionary-for-id_-embedding-in-zipresultsids-resultsembeddings-for-id_-embedding-in-zipresultsids-normalizeresultsembeddings-norm-l2-embeddings_dictid_-nparrayembedding-except-exception-as-e-printferror-loading-collection-collection_name-stre-continue-create-a-new-dataframe-with-the-same-rows-as-name_df-full_df-name_dfcopy-add-embeddings-to-the-dataframe-full_dfembedding-full_dfidmapembeddings_dict-drop-rows-where-no-embedding-was-found-if-desired-full_df-full_dfdropnasubsetembedding-return-full_df-step-3-filter-embeddings-to-minhash-cluster-representatives-def-filter_to_representativesfull_df-pddataframe-rep_map-dictstr-str-pddataframe-filter-full_df-rows-to-only-those-whose-name-is-a-cluster-representative-reps-setrep_mapvalues-filtered-full_dffull_dfnameisinrepsreset_indexdroptrue-return-filtered-step-4-hdbscan-clustering-on-embeddings-def-hdbscan_cluster_embeddingsembeddings-npndarray-min_cluster_size-int-5-min_samples-int-none-epsilon_value-float-00-npndarray-run-cuml-hdbscan-clustering-on-embeddings-array-clusterer-hdbscanmin_cluster_sizemin_cluster_size-min_samplesmin_samples-cluster_selection_epsilon-epsilon_value-metric-euclidean-verbose-3-labels-clustererfit_predictembeddings-return-labels-def-dbscan_cluster_embeddingsembeddings-npndarray-min_cluster_size-int-5-min_samples-int-none-epsilon_value-float-00-npndarray-run-cuml-hdbscan-clustering-on-embeddings-array-clusterer-dbscan-min_cluster_sizemin_cluster_size-min_samplesmin_samples-eps-epsilon_value-metric-cosine-verbose-3-labels-clustererfit_predictembeddings-return-labels-step-5-assign-medoid-as-cluster-representative-id-def-assign_medoid_representativeembeddings-npndarray-labels-npndarray-ids-liststr-dictint-str-for-each-cluster-find-medoid-closest-embedding-to-cluster-centroid-returns-dict-cluster_label-medoid_id-cluster_medoid-for-cluster_label-in-setlabels-if-cluster_label-1-noise-cluster-no-medoid-continue-cluster_indices-npwherelabels-cluster_label0-cluster_embeds-embeddingscluster_indices-compute-centroid-centroid-cluster_embedsmeanaxis0reshape1-1-find-closest-embedding-to-centroid-medoid-medoid_idx-_-pairwise_distances_argmin_mincentroid-cluster_embeds-medoid_id-idscluster_indicesmedoid_idx0-cluster_medoidcluster_label-medoid_id-return-cluster_medoid-def-assign_count_based_representativerep_df-pddataframe-cluster_labels-npndarray-dictint-str-for-each-cluster-find-the-representative-with-the-highest-count-if-count-column-is-not-available-falls-back-to-medoid-logic-returns-dict-cluster_label-count_based_rep_id-cluster_rep_ids-if-count-not-in-rep_dfcolumns-printwarning-count-column-not-found-in-representative-dataframe-falling-back-to-medoid-based-representatives-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-return-assign_medoid_representativeembeddings_array-cluster_labels-rep_dfidtolist-for-cluster_label-in-setcluster_labels-if-cluster_label-1-continue-cluster_rows-rep_dfcluster_labels-cluster_label-find-the-row-with-the-maximum-count-in-case-of-a-tie-idxmax-will-return-the-first-occurrence-which-is-fine-max_count_row-cluster_rowsloccluster_rowscountidxmax-cluster_rep_idscluster_label-max_count_rowid-return-cluster_rep_ids-step-6-build-final-dataframe-with-cluster_id-and-cluster_rep_id-per-original-id-def-build_final_mapping-full_df-pddataframe-rep_df-pddataframe-rep_map-dictstr-str-cluster_labels-npndarray-use_count_rep-bool-false-pddataframe-assign-cluster_id-and-cluster_rep_id-for-all-original-ids-args-full_df-dataframe-with-all-original-ids-names-embeddings-and-optionally-a-count-column-rep_df-dataframe-with-representatives-only-their-embeddings-and-cluster-labels-rep_map-map-original-name-representative-name-string-cluster_labels-hdbscan-cluster-labels-for-rep_df-rows-use_count_rep-if-true-uses-the-highest-count-item-as-cluster-representative-otherwise-uses-the-medoid-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-count-if-present-in-input-rep_df-rep_dfcopy-rep_dfcluster_id-cluster_labels-choose-representative-assignment-method-if-use_count_rep-and-count-in-rep_dfcolumns-printassigning-cluster-representatives-based-on-highest-count-cluster_rep_map-assign_count_based_representativerep_df-cluster_labels-else-printassigning-cluster-representatives-based-on-medoid-closest-to-centroid-embeddings_array-npvstackrep_dfembeddingtolist-cluster_rep_map-assign_medoid_representativeembeddings_array-cluster_labels-rep_dfidtolist-map-representative-name-to-id-rep_name_to_id-dictziprep_dfname-rep_dfid-rows-noise_count-0-total-lenfull_df-total_count-0-for-_-row-in-full_dfiterrows-name-rowname-orig_id-rowid-count-rowgetcount-1-default-to-1-if-no-count-column-total_count-count-rep_name-rep_mapgetname-name-rep_id-rep_name_to_idgetrep_name-cluster_id-none-if-rep_id-rep_cluster_idx-rep_dfindexrep_dfid-rep_id-if-lenrep_cluster_idx-1-cluster_id-rep_dflocrep_cluster_idx0-cluster_id-if-cluster_id-1-cluster_rep_id-rep_id-noise_count-1-else-cluster_rep_id-cluster_rep_mapgetcluster_id-rep_id-row_data-id-orig_id-name-name-cluster_id-cluster_id-cluster_rep_id-cluster_rep_id-if-count-in-full_dfcolumns-row_datacount-count-rowsappendrow_data-result_df-pddataframerows-log-cluster-summary-num_clusters-lensetcluster_labels-1-if-1-in-cluster_labels-else-0-printf-mapping-complete-total-rows-total_count-total-count-printf-num_clusters-clusters-formed-printf-noise_count-items-marked-as-noise-singleton-clusters-optional-summary-of-total-count-per-cluster-rep-if-count-in-result_dfcolumns-cluster_summary-result_dfgroupbycluster_rep_idcount-sum-sort_valuesascendingfalse-printn-top-cluster-representatives-by-total-count-printcluster_summaryhead10-return-result_df-main-pipeline-function-def-full_deduplication_pipeline-all_names-liststr-full_df-pddataframe-minhash_threshold-float-08-num_perm-int-128-hdbscan_min_cluster_size-int-5-hdbscan_min_samples-int-none-epsilon_valuefloat-00-use_count_rep-bool-false-pddataframe-run-full-deduplication-pipeline-1-minhash-deduplication-on-names-2-load-embeddings-and-ids-from-chromadb-collections-this-wil-be-done-before-3-filter-embeddings-to-minhash-cluster-representatives-4-run-hdbscan-on-embeddings-of-representatives-5-assign-medoid-representatives-per-cluster-6-map-all-original-ids-to-cluster_id-and-cluster_rep_id-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-printrunning-minhash-deduplication-on-names-get-a-series-of-counts-for-minhash-clustering-representative-selection-if-count-in-full_dfcolumns-name_counts-full_dfgroupbynamecountsum-else-name_counts-pdseries1-indexfull_dfnameunique-clusters-minhash_clusterall_names-thresholdminhash_threshold-num_permnum_perm-rep_map-get_cluster_representativesclusters-name_counts-printffiltering-embeddings-to-lensetrep_mapvalues-cluster-representatives-rep_df-filter_to_representativesfull_df-rep_map-printrunning-hdbscan-on-representative-embeddings-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-cluster_labels-hdbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-epsilon_value-epsilon_value-cluster_labels-dbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-epsilon_value-epsilon_value-printbuilding-final-mapping-of-all-ids-to-cluster-ids-and-representative-ids-final_df-build_final_mappingfull_df-rep_df-rep_map-cluster_labels-use_count_repuse_count_rep-return-final_df-def-deduplication_pipeline_testing-all_names-liststr-full_df-pddataframe-rep_map-hdbscan_min_cluster_size-int-5-hdbscan_min_samples-int-none-pddataframe-run-full-deduplication-pipeline-1-minhash-deduplication-on-names-2-load-embeddings-and-ids-from-chromadb-collections-this-wil-be-done-before-3-filter-embeddings-to-minhash-cluster-representatives-4-run-hdbscan-on-embeddings-of-representatives-5-assign-medoid-representatives-per-cluster-6-map-all-original-ids-to-cluster_id-and-cluster_rep_id-returns-dataframe-with-columns-id-name-cluster_id-cluster_rep_id-printffiltering-embeddings-to-lensetrep_mapvalues-cluster-representatives-rep_df-filter_to_representativesfull_df-rep_map-printrunning-hdbscan-on-representative-embeddings-embeddings_array-npvstackrep_dfembeddingvaluesastypenpfloat32-cluster_labels-hdbscan_cluster_embeddings-embeddings_array-min_cluster_sizehdbscan_min_cluster_size-min_sampleshdbscan_min_samples-printbuilding-final-mapping-of-all-ids-to-cluster-ids-and-representative-ids-final_df-build_final_mappingfull_df-rep_df-rep_map-cluster_labels-return-final_df"><div class="language-python highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
</span><span id="__span-5-3"><a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a><span class="kn">from</span><span class="w"> </span><span class="nn">datasketch</span><span class="w"> </span><span class="kn">import</span> <span class="n">MinHash</span><span class="p">,</span> <span class="n">MinHashLSH</span>
</span><span id="__span-5-4"><a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="kn">from</span><span class="w"> </span><span class="nn">tqdm.auto</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
</span><span id="__span-5-5"><a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="kn">from</span><span class="w"> </span><span class="nn">cuml.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">HDBSCAN</span><span class="p">,</span> <span class="n">DBSCAN</span>
</span><span id="__span-5-6"><a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">pairwise_distances_argmin_min</span>
</span><span id="__span-5-7"><a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize</span> <span class="c1"># Import normalize</span>
</span><span id="__span-5-8"><a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a><span class="kn">import</span><span class="w"> </span><span class="nn">chromadb</span>
</span><span id="__span-5-9"><a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a>
</span><span id="__span-5-10"><a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-11"><a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a><span class="c1"># Step 1: MinHash Deduplication on Names</span>
</span><span id="__span-5-12"><a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-13"><a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a>
</span><span id="__span-5-14"><a id="__codelineno-5-14" name="__codelineno-5-14" href="#__codelineno-5-14"></a><span class="k">def</span><span class="w"> </span><span class="nf">get_minhash</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num_perm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MinHash</span><span class="p">:</span>
</span><span id="__span-5-15"><a id="__codelineno-5-15" name="__codelineno-5-15" href="#__codelineno-5-15"></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">MinHash</span><span class="p">(</span><span class="n">num_perm</span><span class="o">=</span><span class="n">num_perm</span><span class="p">)</span>
</span><span id="__span-5-16"><a id="__codelineno-5-16" name="__codelineno-5-16" href="#__codelineno-5-16"></a>    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()):</span>
</span><span id="__span-5-17"><a id="__codelineno-5-17" name="__codelineno-5-17" href="#__codelineno-5-17"></a>        <span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
</span><span id="__span-5-18"><a id="__codelineno-5-18" name="__codelineno-5-18" href="#__codelineno-5-18"></a>    <span class="k">return</span> <span class="n">m</span>
</span><span id="__span-5-19"><a id="__codelineno-5-19" name="__codelineno-5-19" href="#__codelineno-5-19"></a>
</span><span id="__span-5-20"><a id="__codelineno-5-20" name="__codelineno-5-20" href="#__codelineno-5-20"></a><span class="k">def</span><span class="w"> </span><span class="nf">minhash_cluster</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">num_perm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span><span id="__span-5-21"><a id="__codelineno-5-21" name="__codelineno-5-21" href="#__codelineno-5-21"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-22"><a id="__codelineno-5-22" name="__codelineno-5-22" href="#__codelineno-5-22"></a><span class="sd">    Cluster names by MinHash + LSH and return list of clusters (each a list of names).</span>
</span><span id="__span-5-23"><a id="__codelineno-5-23" name="__codelineno-5-23" href="#__codelineno-5-23"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-24"><a id="__codelineno-5-24" name="__codelineno-5-24" href="#__codelineno-5-24"></a>    <span class="n">lsh</span> <span class="o">=</span> <span class="n">MinHashLSH</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">num_perm</span><span class="o">=</span><span class="n">num_perm</span><span class="p">)</span>
</span><span id="__span-5-25"><a id="__codelineno-5-25" name="__codelineno-5-25" href="#__codelineno-5-25"></a>    <span class="n">minhashes</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="__span-5-26"><a id="__codelineno-5-26" name="__codelineno-5-26" href="#__codelineno-5-26"></a>
</span><span id="__span-5-27"><a id="__codelineno-5-27" name="__codelineno-5-27" href="#__codelineno-5-27"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Indexing names with MinHash...&quot;</span><span class="p">)</span>
</span><span id="__span-5-28"><a id="__codelineno-5-28" name="__codelineno-5-28" href="#__codelineno-5-28"></a>    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
</span><span id="__span-5-29"><a id="__codelineno-5-29" name="__codelineno-5-29" href="#__codelineno-5-29"></a>        <span class="n">mh</span> <span class="o">=</span> <span class="n">get_minhash</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">num_perm</span><span class="p">)</span>
</span><span id="__span-5-30"><a id="__codelineno-5-30" name="__codelineno-5-30" href="#__codelineno-5-30"></a>        <span class="n">lsh</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">mh</span><span class="p">)</span>
</span><span id="__span-5-31"><a id="__codelineno-5-31" name="__codelineno-5-31" href="#__codelineno-5-31"></a>        <span class="n">minhashes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mh</span>
</span><span id="__span-5-32"><a id="__codelineno-5-32" name="__codelineno-5-32" href="#__codelineno-5-32"></a>
</span><span id="__span-5-33"><a id="__codelineno-5-33" name="__codelineno-5-33" href="#__codelineno-5-33"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Querying clusters from LSH...&quot;</span><span class="p">)</span>
</span><span id="__span-5-34"><a id="__codelineno-5-34" name="__codelineno-5-34" href="#__codelineno-5-34"></a>    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</span><span id="__span-5-35"><a id="__codelineno-5-35" name="__codelineno-5-35" href="#__codelineno-5-35"></a>    <span class="n">clusters</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="__span-5-36"><a id="__codelineno-5-36" name="__codelineno-5-36" href="#__codelineno-5-36"></a>
</span><span id="__span-5-37"><a id="__codelineno-5-37" name="__codelineno-5-37" href="#__codelineno-5-37"></a>    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
</span><span id="__span-5-38"><a id="__codelineno-5-38" name="__codelineno-5-38" href="#__codelineno-5-38"></a>        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
</span><span id="__span-5-39"><a id="__codelineno-5-39" name="__codelineno-5-39" href="#__codelineno-5-39"></a>            <span class="k">continue</span>
</span><span id="__span-5-40"><a id="__codelineno-5-40" name="__codelineno-5-40" href="#__codelineno-5-40"></a>        <span class="n">cluster</span> <span class="o">=</span> <span class="n">lsh</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">minhashes</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
</span><span id="__span-5-41"><a id="__codelineno-5-41" name="__codelineno-5-41" href="#__codelineno-5-41"></a>        <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
</span><span id="__span-5-42"><a id="__codelineno-5-42" name="__codelineno-5-42" href="#__codelineno-5-42"></a>        <span class="n">visited</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
</span><span id="__span-5-43"><a id="__codelineno-5-43" name="__codelineno-5-43" href="#__codelineno-5-43"></a>
</span><span id="__span-5-44"><a id="__codelineno-5-44" name="__codelineno-5-44" href="#__codelineno-5-44"></a>    <span class="k">return</span> <span class="n">clusters</span>
</span><span id="__span-5-45"><a id="__codelineno-5-45" name="__codelineno-5-45" href="#__codelineno-5-45"></a>
</span><span id="__span-5-46"><a id="__codelineno-5-46" name="__codelineno-5-46" href="#__codelineno-5-46"></a><span class="k">def</span><span class="w"> </span><span class="nf">get_cluster_representatives</span><span class="p">(</span><span class="n">clusters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">name_counts</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
</span><span id="__span-5-47"><a id="__codelineno-5-47" name="__codelineno-5-47" href="#__codelineno-5-47"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-48"><a id="__codelineno-5-48" name="__codelineno-5-48" href="#__codelineno-5-48"></a><span class="sd">    Pick a representative name per cluster.</span>
</span><span id="__span-5-49"><a id="__codelineno-5-49" name="__codelineno-5-49" href="#__codelineno-5-49"></a><span class="sd">    The representative is chosen based on the highest count,</span>
</span><span id="__span-5-50"><a id="__codelineno-5-50" name="__codelineno-5-50" href="#__codelineno-5-50"></a><span class="sd">    or the shortest string if counts are equal or not available.</span>
</span><span id="__span-5-51"><a id="__codelineno-5-51" name="__codelineno-5-51" href="#__codelineno-5-51"></a><span class="sd">    Returns map: name -&gt; cluster_rep_name</span>
</span><span id="__span-5-52"><a id="__codelineno-5-52" name="__codelineno-5-52" href="#__codelineno-5-52"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-53"><a id="__codelineno-5-53" name="__codelineno-5-53" href="#__codelineno-5-53"></a>    <span class="n">rep_map</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="__span-5-54"><a id="__codelineno-5-54" name="__codelineno-5-54" href="#__codelineno-5-54"></a>    <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
</span><span id="__span-5-55"><a id="__codelineno-5-55" name="__codelineno-5-55" href="#__codelineno-5-55"></a>        <span class="c1"># Get counts for names in the current cluster</span>
</span><span id="__span-5-56"><a id="__codelineno-5-56" name="__codelineno-5-56" href="#__codelineno-5-56"></a>        <span class="n">cluster_counts</span> <span class="o">=</span> <span class="n">name_counts</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="__span-5-57"><a id="__codelineno-5-57" name="__codelineno-5-57" href="#__codelineno-5-57"></a>
</span><span id="__span-5-58"><a id="__codelineno-5-58" name="__codelineno-5-58" href="#__codelineno-5-58"></a>        <span class="c1"># Find the name with the maximum count</span>
</span><span id="__span-5-59"><a id="__codelineno-5-59" name="__codelineno-5-59" href="#__codelineno-5-59"></a>        <span class="c1"># If there&#39;s a tie, min() will pick the one that comes first alphabetically,</span>
</span><span id="__span-5-60"><a id="__codelineno-5-60" name="__codelineno-5-60" href="#__codelineno-5-60"></a>        <span class="c1"># but we want to break ties by shortest length. So we&#39;ll find max count first.</span>
</span><span id="__span-5-61"><a id="__codelineno-5-61" name="__codelineno-5-61" href="#__codelineno-5-61"></a>        <span class="n">max_count</span> <span class="o">=</span> <span class="n">cluster_counts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</span><span id="__span-5-62"><a id="__codelineno-5-62" name="__codelineno-5-62" href="#__codelineno-5-62"></a>
</span><span id="__span-5-63"><a id="__codelineno-5-63" name="__codelineno-5-63" href="#__codelineno-5-63"></a>        <span class="c1"># Get all names with the maximum count</span>
</span><span id="__span-5-64"><a id="__codelineno-5-64" name="__codelineno-5-64" href="#__codelineno-5-64"></a>        <span class="n">candidates</span> <span class="o">=</span> <span class="n">cluster_counts</span><span class="p">[</span><span class="n">cluster_counts</span> <span class="o">==</span> <span class="n">max_count</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</span><span id="__span-5-65"><a id="__codelineno-5-65" name="__codelineno-5-65" href="#__codelineno-5-65"></a>
</span><span id="__span-5-66"><a id="__codelineno-5-66" name="__codelineno-5-66" href="#__codelineno-5-66"></a>        <span class="c1"># From the candidates, pick the one with the shortest length</span>
</span><span id="__span-5-67"><a id="__codelineno-5-67" name="__codelineno-5-67" href="#__codelineno-5-67"></a>        <span class="n">rep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</span><span id="__span-5-68"><a id="__codelineno-5-68" name="__codelineno-5-68" href="#__codelineno-5-68"></a>
</span><span id="__span-5-69"><a id="__codelineno-5-69" name="__codelineno-5-69" href="#__codelineno-5-69"></a>        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
</span><span id="__span-5-70"><a id="__codelineno-5-70" name="__codelineno-5-70" href="#__codelineno-5-70"></a>            <span class="n">rep_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep</span>
</span><span id="__span-5-71"><a id="__codelineno-5-71" name="__codelineno-5-71" href="#__codelineno-5-71"></a>    <span class="k">return</span> <span class="n">rep_map</span>
</span><span id="__span-5-72"><a id="__codelineno-5-72" name="__codelineno-5-72" href="#__codelineno-5-72"></a>
</span><span id="__span-5-73"><a id="__codelineno-5-73" name="__codelineno-5-73" href="#__codelineno-5-73"></a>
</span><span id="__span-5-74"><a id="__codelineno-5-74" name="__codelineno-5-74" href="#__codelineno-5-74"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-75"><a id="__codelineno-5-75" name="__codelineno-5-75" href="#__codelineno-5-75"></a><span class="c1"># Step 2: Load Embeddings and IDs from ChromaDB</span>
</span><span id="__span-5-76"><a id="__codelineno-5-76" name="__codelineno-5-76" href="#__codelineno-5-76"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-77"><a id="__codelineno-5-77" name="__codelineno-5-77" href="#__codelineno-5-77"></a>
</span><span id="__span-5-78"><a id="__codelineno-5-78" name="__codelineno-5-78" href="#__codelineno-5-78"></a><span class="c1"># def load_all_embeddings(chroma_collection_names: list[str]) -&gt; pd.DataFrame:</span>
</span><span id="__span-5-79"><a id="__codelineno-5-79" name="__codelineno-5-79" href="#__codelineno-5-79"></a>    <span class="c1"># &quot;&quot;&quot;</span>
</span><span id="__span-5-80"><a id="__codelineno-5-80" name="__codelineno-5-80" href="#__codelineno-5-80"></a>    <span class="c1"># Fetch all embeddings + ids + names from multiple ChromaDB collections, combine into one DataFrame.</span>
</span><span id="__span-5-81"><a id="__codelineno-5-81" name="__codelineno-5-81" href="#__codelineno-5-81"></a>    <span class="c1"># Returns DataFrame with columns: id, name, embedding (np.array)</span>
</span><span id="__span-5-82"><a id="__codelineno-5-82" name="__codelineno-5-82" href="#__codelineno-5-82"></a>    <span class="c1"># &quot;&quot;&quot;</span>
</span><span id="__span-5-83"><a id="__codelineno-5-83" name="__codelineno-5-83" href="#__codelineno-5-83"></a>    <span class="c1"># chroma_client = chromadb.HttpClient(host = &#39;34.71.102.215&#39;, port = 8000)</span>
</span><span id="__span-5-84"><a id="__codelineno-5-84" name="__codelineno-5-84" href="#__codelineno-5-84"></a>    <span class="c1"># all_data = []</span>
</span><span id="__span-5-85"><a id="__codelineno-5-85" name="__codelineno-5-85" href="#__codelineno-5-85"></a>
</span><span id="__span-5-86"><a id="__codelineno-5-86" name="__codelineno-5-86" href="#__codelineno-5-86"></a>    <span class="c1"># for collection_name in chroma_collection_names:</span>
</span><span id="__span-5-87"><a id="__codelineno-5-87" name="__codelineno-5-87" href="#__codelineno-5-87"></a>    <span class="c1">#     collection = chroma_client.get_collection(collection_name)</span>
</span><span id="__span-5-88"><a id="__codelineno-5-88" name="__codelineno-5-88" href="#__codelineno-5-88"></a>    <span class="c1">#     results = collection.get(include=[&quot;embeddings&quot;, &#39;metadatas&#39;])</span>
</span><span id="__span-5-89"><a id="__codelineno-5-89" name="__codelineno-5-89" href="#__codelineno-5-89"></a>    <span class="c1">#     # ids = unique IDs in collection</span>
</span><span id="__span-5-90"><a id="__codelineno-5-90" name="__codelineno-5-90" href="#__codelineno-5-90"></a>    <span class="c1">#     # embeddings = list of vectors</span>
</span><span id="__span-5-91"><a id="__codelineno-5-91" name="__codelineno-5-91" href="#__codelineno-5-91"></a>    <span class="c1">#     ids = results[&quot;ids&quot;]</span>
</span><span id="__span-5-92"><a id="__codelineno-5-92" name="__codelineno-5-92" href="#__codelineno-5-92"></a>    <span class="c1">#     embeddings = results[&quot;embeddings&quot;]</span>
</span><span id="__span-5-93"><a id="__codelineno-5-93" name="__codelineno-5-93" href="#__codelineno-5-93"></a>    <span class="c1">#     metadatas = results[&#39;metadatas&#39;]</span>
</span><span id="__span-5-94"><a id="__codelineno-5-94" name="__codelineno-5-94" href="#__codelineno-5-94"></a>
</span><span id="__span-5-95"><a id="__codelineno-5-95" name="__codelineno-5-95" href="#__codelineno-5-95"></a>    <span class="c1">#     df = pd.DataFrame({&quot;id&quot;: ids})</span>
</span><span id="__span-5-96"><a id="__codelineno-5-96" name="__codelineno-5-96" href="#__codelineno-5-96"></a>    <span class="c1">#     df[&quot;embedding&quot;] = [e for e in embeddings]</span>
</span><span id="__span-5-97"><a id="__codelineno-5-97" name="__codelineno-5-97" href="#__codelineno-5-97"></a>    <span class="c1">#     df[&#39;name&#39;] = [meta[&#39;name&#39;] for meta in metadatas]</span>
</span><span id="__span-5-98"><a id="__codelineno-5-98" name="__codelineno-5-98" href="#__codelineno-5-98"></a>    <span class="c1">#     all_data.append(df)</span>
</span><span id="__span-5-99"><a id="__codelineno-5-99" name="__codelineno-5-99" href="#__codelineno-5-99"></a>
</span><span id="__span-5-100"><a id="__codelineno-5-100" name="__codelineno-5-100" href="#__codelineno-5-100"></a>    <span class="c1"># full_df = pd.concat(all_data, ignore_index=True)</span>
</span><span id="__span-5-101"><a id="__codelineno-5-101" name="__codelineno-5-101" href="#__codelineno-5-101"></a>    <span class="c1"># # Remove duplicate names keeping first appearance</span>
</span><span id="__span-5-102"><a id="__codelineno-5-102" name="__codelineno-5-102" href="#__codelineno-5-102"></a>    <span class="c1"># full_df = full_df.drop_duplicates(subset=&quot;id&quot;).reset_index(drop=True)</span>
</span><span id="__span-5-103"><a id="__codelineno-5-103" name="__codelineno-5-103" href="#__codelineno-5-103"></a>    <span class="c1"># return full_df</span>
</span><span id="__span-5-104"><a id="__codelineno-5-104" name="__codelineno-5-104" href="#__codelineno-5-104"></a><span class="k">def</span><span class="w"> </span><span class="nf">load_all_embeddings</span><span class="p">(</span><span class="n">name_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">chroma_collection_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
</span><span id="__span-5-105"><a id="__codelineno-5-105" name="__codelineno-5-105" href="#__codelineno-5-105"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-106"><a id="__codelineno-5-106" name="__codelineno-5-106" href="#__codelineno-5-106"></a><span class="sd">    Fetch all embeddings + ids + names from multiple ChromaDB collections, combine into one DataFrame.</span>
</span><span id="__span-5-107"><a id="__codelineno-5-107" name="__codelineno-5-107" href="#__codelineno-5-107"></a>
</span><span id="__span-5-108"><a id="__codelineno-5-108" name="__codelineno-5-108" href="#__codelineno-5-108"></a><span class="sd">    Args:</span>
</span><span id="__span-5-109"><a id="__codelineno-5-109" name="__codelineno-5-109" href="#__codelineno-5-109"></a><span class="sd">        name_df: DataFrame containing &#39;id&#39; and &#39;name&#39; columns to match with embeddings</span>
</span><span id="__span-5-110"><a id="__codelineno-5-110" name="__codelineno-5-110" href="#__codelineno-5-110"></a><span class="sd">        chroma_collection_names: List of ChromaDB collection names to fetch embeddings from</span>
</span><span id="__span-5-111"><a id="__codelineno-5-111" name="__codelineno-5-111" href="#__codelineno-5-111"></a>
</span><span id="__span-5-112"><a id="__codelineno-5-112" name="__codelineno-5-112" href="#__codelineno-5-112"></a><span class="sd">    Returns:</span>
</span><span id="__span-5-113"><a id="__codelineno-5-113" name="__codelineno-5-113" href="#__codelineno-5-113"></a><span class="sd">        DataFrame with columns: id, name, embedding (np.array)</span>
</span><span id="__span-5-114"><a id="__codelineno-5-114" name="__codelineno-5-114" href="#__codelineno-5-114"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-115"><a id="__codelineno-5-115" name="__codelineno-5-115" href="#__codelineno-5-115"></a>    <span class="n">chroma_client</span> <span class="o">=</span> <span class="n">chromadb</span><span class="o">.</span><span class="n">HttpClient</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;34.71.102.215&#39;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">8000</span><span class="p">)</span>
</span><span id="__span-5-116"><a id="__codelineno-5-116" name="__codelineno-5-116" href="#__codelineno-5-116"></a>
</span><span id="__span-5-117"><a id="__codelineno-5-117" name="__codelineno-5-117" href="#__codelineno-5-117"></a>    <span class="c1"># Create a dictionary to store embeddings by ID for faster lookup</span>
</span><span id="__span-5-118"><a id="__codelineno-5-118" name="__codelineno-5-118" href="#__codelineno-5-118"></a>    <span class="n">embeddings_dict</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="__span-5-119"><a id="__codelineno-5-119" name="__codelineno-5-119" href="#__codelineno-5-119"></a>
</span><span id="__span-5-120"><a id="__codelineno-5-120" name="__codelineno-5-120" href="#__codelineno-5-120"></a>    <span class="k">for</span> <span class="n">collection_name</span> <span class="ow">in</span> <span class="n">chroma_collection_names</span><span class="p">:</span>
</span><span id="__span-5-121"><a id="__codelineno-5-121" name="__codelineno-5-121" href="#__codelineno-5-121"></a>        <span class="k">try</span><span class="p">:</span>
</span><span id="__span-5-122"><a id="__codelineno-5-122" name="__codelineno-5-122" href="#__codelineno-5-122"></a>            <span class="n">collection</span> <span class="o">=</span> <span class="n">chroma_client</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="n">collection_name</span><span class="p">)</span>
</span><span id="__span-5-123"><a id="__codelineno-5-123" name="__codelineno-5-123" href="#__codelineno-5-123"></a>            <span class="n">results</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;embeddings&quot;</span><span class="p">])</span>
</span><span id="__span-5-124"><a id="__codelineno-5-124" name="__codelineno-5-124" href="#__codelineno-5-124"></a>
</span><span id="__span-5-125"><a id="__codelineno-5-125" name="__codelineno-5-125" href="#__codelineno-5-125"></a>            <span class="c1"># Store each id and its corresponding embedding in the dictionary</span>
</span><span id="__span-5-126"><a id="__codelineno-5-126" name="__codelineno-5-126" href="#__codelineno-5-126"></a>            <span class="c1"># for id_, embedding in zip(results[&quot;ids&quot;], results[&quot;embeddings&quot;]):</span>
</span><span id="__span-5-127"><a id="__codelineno-5-127" name="__codelineno-5-127" href="#__codelineno-5-127"></a>            <span class="k">for</span> <span class="n">id_</span><span class="p">,</span> <span class="n">embedding</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;ids&quot;</span><span class="p">],</span> <span class="n">normalize</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;embeddings&quot;</span><span class="p">],</span> <span class="n">norm</span> <span class="o">=</span> <span class="s1">&#39;l2&#39;</span><span class="p">)):</span>
</span><span id="__span-5-128"><a id="__codelineno-5-128" name="__codelineno-5-128" href="#__codelineno-5-128"></a>                <span class="n">embeddings_dict</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">embedding</span><span class="p">)</span>
</span><span id="__span-5-129"><a id="__codelineno-5-129" name="__codelineno-5-129" href="#__codelineno-5-129"></a>
</span><span id="__span-5-130"><a id="__codelineno-5-130" name="__codelineno-5-130" href="#__codelineno-5-130"></a>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span id="__span-5-131"><a id="__codelineno-5-131" name="__codelineno-5-131" href="#__codelineno-5-131"></a>            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error loading collection </span><span class="si">{</span><span class="n">collection_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span id="__span-5-132"><a id="__codelineno-5-132" name="__codelineno-5-132" href="#__codelineno-5-132"></a>            <span class="k">continue</span>
</span><span id="__span-5-133"><a id="__codelineno-5-133" name="__codelineno-5-133" href="#__codelineno-5-133"></a>
</span><span id="__span-5-134"><a id="__codelineno-5-134" name="__codelineno-5-134" href="#__codelineno-5-134"></a>    <span class="c1"># Create a new DataFrame with the same rows as name_df</span>
</span><span id="__span-5-135"><a id="__codelineno-5-135" name="__codelineno-5-135" href="#__codelineno-5-135"></a>    <span class="n">full_df</span> <span class="o">=</span> <span class="n">name_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span><span id="__span-5-136"><a id="__codelineno-5-136" name="__codelineno-5-136" href="#__codelineno-5-136"></a>
</span><span id="__span-5-137"><a id="__codelineno-5-137" name="__codelineno-5-137" href="#__codelineno-5-137"></a>    <span class="c1"># Add embeddings to the DataFrame</span>
</span><span id="__span-5-138"><a id="__codelineno-5-138" name="__codelineno-5-138" href="#__codelineno-5-138"></a>    <span class="n">full_df</span><span class="p">[</span><span class="s1">&#39;embedding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">embeddings_dict</span><span class="p">)</span>
</span><span id="__span-5-139"><a id="__codelineno-5-139" name="__codelineno-5-139" href="#__codelineno-5-139"></a>
</span><span id="__span-5-140"><a id="__codelineno-5-140" name="__codelineno-5-140" href="#__codelineno-5-140"></a>    <span class="c1"># Drop rows where no embedding was found (if desired)</span>
</span><span id="__span-5-141"><a id="__codelineno-5-141" name="__codelineno-5-141" href="#__codelineno-5-141"></a>    <span class="n">full_df</span> <span class="o">=</span> <span class="n">full_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;embedding&#39;</span><span class="p">])</span>
</span><span id="__span-5-142"><a id="__codelineno-5-142" name="__codelineno-5-142" href="#__codelineno-5-142"></a>
</span><span id="__span-5-143"><a id="__codelineno-5-143" name="__codelineno-5-143" href="#__codelineno-5-143"></a>    <span class="k">return</span> <span class="n">full_df</span>
</span><span id="__span-5-144"><a id="__codelineno-5-144" name="__codelineno-5-144" href="#__codelineno-5-144"></a>
</span><span id="__span-5-145"><a id="__codelineno-5-145" name="__codelineno-5-145" href="#__codelineno-5-145"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-146"><a id="__codelineno-5-146" name="__codelineno-5-146" href="#__codelineno-5-146"></a><span class="c1"># Step 3: Filter Embeddings to MinHash Cluster Representatives</span>
</span><span id="__span-5-147"><a id="__codelineno-5-147" name="__codelineno-5-147" href="#__codelineno-5-147"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-148"><a id="__codelineno-5-148" name="__codelineno-5-148" href="#__codelineno-5-148"></a>
</span><span id="__span-5-149"><a id="__codelineno-5-149" name="__codelineno-5-149" href="#__codelineno-5-149"></a><span class="k">def</span><span class="w"> </span><span class="nf">filter_to_representatives</span><span class="p">(</span><span class="n">full_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">rep_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
</span><span id="__span-5-150"><a id="__codelineno-5-150" name="__codelineno-5-150" href="#__codelineno-5-150"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-151"><a id="__codelineno-5-151" name="__codelineno-5-151" href="#__codelineno-5-151"></a><span class="sd">    Filter full_df rows to only those whose name is a cluster representative.</span>
</span><span id="__span-5-152"><a id="__codelineno-5-152" name="__codelineno-5-152" href="#__codelineno-5-152"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-153"><a id="__codelineno-5-153" name="__codelineno-5-153" href="#__codelineno-5-153"></a>    <span class="n">reps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rep_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</span><span id="__span-5-154"><a id="__codelineno-5-154" name="__codelineno-5-154" href="#__codelineno-5-154"></a>    <span class="n">filtered</span> <span class="o">=</span> <span class="n">full_df</span><span class="p">[</span><span class="n">full_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">reps</span><span class="p">)]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="__span-5-155"><a id="__codelineno-5-155" name="__codelineno-5-155" href="#__codelineno-5-155"></a>    <span class="k">return</span> <span class="n">filtered</span>
</span><span id="__span-5-156"><a id="__codelineno-5-156" name="__codelineno-5-156" href="#__codelineno-5-156"></a>
</span><span id="__span-5-157"><a id="__codelineno-5-157" name="__codelineno-5-157" href="#__codelineno-5-157"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-158"><a id="__codelineno-5-158" name="__codelineno-5-158" href="#__codelineno-5-158"></a><span class="c1"># Step 4: HDBSCAN Clustering on Embeddings</span>
</span><span id="__span-5-159"><a id="__codelineno-5-159" name="__codelineno-5-159" href="#__codelineno-5-159"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-160"><a id="__codelineno-5-160" name="__codelineno-5-160" href="#__codelineno-5-160"></a>
</span><span id="__span-5-161"><a id="__codelineno-5-161" name="__codelineno-5-161" href="#__codelineno-5-161"></a><span class="k">def</span><span class="w"> </span><span class="nf">hdbscan_cluster_embeddings</span><span class="p">(</span><span class="n">embeddings</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="__span-5-162"><a id="__codelineno-5-162" name="__codelineno-5-162" href="#__codelineno-5-162"></a>                              <span class="n">epsilon_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
</span><span id="__span-5-163"><a id="__codelineno-5-163" name="__codelineno-5-163" href="#__codelineno-5-163"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-164"><a id="__codelineno-5-164" name="__codelineno-5-164" href="#__codelineno-5-164"></a><span class="sd">    Run cuML HDBSCAN clustering on embeddings array.</span>
</span><span id="__span-5-165"><a id="__codelineno-5-165" name="__codelineno-5-165" href="#__codelineno-5-165"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-166"><a id="__codelineno-5-166" name="__codelineno-5-166" href="#__codelineno-5-166"></a>    <span class="n">clusterer</span> <span class="o">=</span> <span class="n">HDBSCAN</span><span class="p">(</span><span class="n">min_cluster_size</span><span class="o">=</span><span class="n">min_cluster_size</span><span class="p">,</span> 
</span><span id="__span-5-167"><a id="__codelineno-5-167" name="__codelineno-5-167" href="#__codelineno-5-167"></a>                        <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> 
</span><span id="__span-5-168"><a id="__codelineno-5-168" name="__codelineno-5-168" href="#__codelineno-5-168"></a>                        <span class="n">cluster_selection_epsilon</span> <span class="o">=</span> <span class="n">epsilon_value</span><span class="p">,</span>
</span><span id="__span-5-169"><a id="__codelineno-5-169" name="__codelineno-5-169" href="#__codelineno-5-169"></a>                        <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
</span><span id="__span-5-170"><a id="__codelineno-5-170" name="__codelineno-5-170" href="#__codelineno-5-170"></a>                        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">3</span>
</span><span id="__span-5-171"><a id="__codelineno-5-171" name="__codelineno-5-171" href="#__codelineno-5-171"></a>                       <span class="p">)</span>
</span><span id="__span-5-172"><a id="__codelineno-5-172" name="__codelineno-5-172" href="#__codelineno-5-172"></a>    <span class="n">labels</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
</span><span id="__span-5-173"><a id="__codelineno-5-173" name="__codelineno-5-173" href="#__codelineno-5-173"></a>    <span class="k">return</span> <span class="n">labels</span>
</span><span id="__span-5-174"><a id="__codelineno-5-174" name="__codelineno-5-174" href="#__codelineno-5-174"></a>
</span><span id="__span-5-175"><a id="__codelineno-5-175" name="__codelineno-5-175" href="#__codelineno-5-175"></a><span class="k">def</span><span class="w"> </span><span class="nf">dbscan_cluster_embeddings</span><span class="p">(</span><span class="n">embeddings</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="__span-5-176"><a id="__codelineno-5-176" name="__codelineno-5-176" href="#__codelineno-5-176"></a>                              <span class="n">epsilon_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
</span><span id="__span-5-177"><a id="__codelineno-5-177" name="__codelineno-5-177" href="#__codelineno-5-177"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-178"><a id="__codelineno-5-178" name="__codelineno-5-178" href="#__codelineno-5-178"></a><span class="sd">    Run cuML HDBSCAN clustering on embeddings array.</span>
</span><span id="__span-5-179"><a id="__codelineno-5-179" name="__codelineno-5-179" href="#__codelineno-5-179"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-180"><a id="__codelineno-5-180" name="__codelineno-5-180" href="#__codelineno-5-180"></a>    <span class="n">clusterer</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span>
</span><span id="__span-5-181"><a id="__codelineno-5-181" name="__codelineno-5-181" href="#__codelineno-5-181"></a>                        <span class="c1"># min_cluster_size=min_cluster_size, </span>
</span><span id="__span-5-182"><a id="__codelineno-5-182" name="__codelineno-5-182" href="#__codelineno-5-182"></a>                        <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span> 
</span><span id="__span-5-183"><a id="__codelineno-5-183" name="__codelineno-5-183" href="#__codelineno-5-183"></a>                        <span class="n">eps</span> <span class="o">=</span> <span class="n">epsilon_value</span><span class="p">,</span>
</span><span id="__span-5-184"><a id="__codelineno-5-184" name="__codelineno-5-184" href="#__codelineno-5-184"></a>                        <span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span>
</span><span id="__span-5-185"><a id="__codelineno-5-185" name="__codelineno-5-185" href="#__codelineno-5-185"></a>                        <span class="n">verbose</span> <span class="o">=</span> <span class="mi">3</span>
</span><span id="__span-5-186"><a id="__codelineno-5-186" name="__codelineno-5-186" href="#__codelineno-5-186"></a>                       <span class="p">)</span>
</span><span id="__span-5-187"><a id="__codelineno-5-187" name="__codelineno-5-187" href="#__codelineno-5-187"></a>    <span class="n">labels</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">embeddings</span><span class="p">)</span>
</span><span id="__span-5-188"><a id="__codelineno-5-188" name="__codelineno-5-188" href="#__codelineno-5-188"></a>    <span class="k">return</span> <span class="n">labels</span>
</span><span id="__span-5-189"><a id="__codelineno-5-189" name="__codelineno-5-189" href="#__codelineno-5-189"></a>
</span><span id="__span-5-190"><a id="__codelineno-5-190" name="__codelineno-5-190" href="#__codelineno-5-190"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-191"><a id="__codelineno-5-191" name="__codelineno-5-191" href="#__codelineno-5-191"></a><span class="c1"># Step 5: Assign Medoid as Cluster Representative ID</span>
</span><span id="__span-5-192"><a id="__codelineno-5-192" name="__codelineno-5-192" href="#__codelineno-5-192"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-193"><a id="__codelineno-5-193" name="__codelineno-5-193" href="#__codelineno-5-193"></a>
</span><span id="__span-5-194"><a id="__codelineno-5-194" name="__codelineno-5-194" href="#__codelineno-5-194"></a><span class="k">def</span><span class="w"> </span><span class="nf">assign_medoid_representative</span><span class="p">(</span><span class="n">embeddings</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ids</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
</span><span id="__span-5-195"><a id="__codelineno-5-195" name="__codelineno-5-195" href="#__codelineno-5-195"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-196"><a id="__codelineno-5-196" name="__codelineno-5-196" href="#__codelineno-5-196"></a><span class="sd">    For each cluster, find medoid (closest embedding to cluster centroid).</span>
</span><span id="__span-5-197"><a id="__codelineno-5-197" name="__codelineno-5-197" href="#__codelineno-5-197"></a><span class="sd">    Returns dict: cluster_label -&gt; medoid_id</span>
</span><span id="__span-5-198"><a id="__codelineno-5-198" name="__codelineno-5-198" href="#__codelineno-5-198"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-199"><a id="__codelineno-5-199" name="__codelineno-5-199" href="#__codelineno-5-199"></a>    <span class="n">cluster_medoid</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="__span-5-200"><a id="__codelineno-5-200" name="__codelineno-5-200" href="#__codelineno-5-200"></a>    <span class="k">for</span> <span class="n">cluster_label</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
</span><span id="__span-5-201"><a id="__codelineno-5-201" name="__codelineno-5-201" href="#__codelineno-5-201"></a>        <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span><span id="__span-5-202"><a id="__codelineno-5-202" name="__codelineno-5-202" href="#__codelineno-5-202"></a>            <span class="c1"># Noise cluster: no medoid</span>
</span><span id="__span-5-203"><a id="__codelineno-5-203" name="__codelineno-5-203" href="#__codelineno-5-203"></a>            <span class="k">continue</span>
</span><span id="__span-5-204"><a id="__codelineno-5-204" name="__codelineno-5-204" href="#__codelineno-5-204"></a>        <span class="n">cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cluster_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="__span-5-205"><a id="__codelineno-5-205" name="__codelineno-5-205" href="#__codelineno-5-205"></a>        <span class="n">cluster_embeds</span> <span class="o">=</span> <span class="n">embeddings</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">]</span>
</span><span id="__span-5-206"><a id="__codelineno-5-206" name="__codelineno-5-206" href="#__codelineno-5-206"></a>
</span><span id="__span-5-207"><a id="__codelineno-5-207" name="__codelineno-5-207" href="#__codelineno-5-207"></a>        <span class="c1"># Compute centroid</span>
</span><span id="__span-5-208"><a id="__codelineno-5-208" name="__codelineno-5-208" href="#__codelineno-5-208"></a>        <span class="n">centroid</span> <span class="o">=</span> <span class="n">cluster_embeds</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span id="__span-5-209"><a id="__codelineno-5-209" name="__codelineno-5-209" href="#__codelineno-5-209"></a>
</span><span id="__span-5-210"><a id="__codelineno-5-210" name="__codelineno-5-210" href="#__codelineno-5-210"></a>        <span class="c1"># Find closest embedding to centroid (medoid)</span>
</span><span id="__span-5-211"><a id="__codelineno-5-211" name="__codelineno-5-211" href="#__codelineno-5-211"></a>        <span class="n">medoid_idx</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pairwise_distances_argmin_min</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="n">cluster_embeds</span><span class="p">)</span>
</span><span id="__span-5-212"><a id="__codelineno-5-212" name="__codelineno-5-212" href="#__codelineno-5-212"></a>        <span class="n">medoid_id</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">medoid_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
</span><span id="__span-5-213"><a id="__codelineno-5-213" name="__codelineno-5-213" href="#__codelineno-5-213"></a>        <span class="n">cluster_medoid</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">medoid_id</span>
</span><span id="__span-5-214"><a id="__codelineno-5-214" name="__codelineno-5-214" href="#__codelineno-5-214"></a>    <span class="k">return</span> <span class="n">cluster_medoid</span>
</span><span id="__span-5-215"><a id="__codelineno-5-215" name="__codelineno-5-215" href="#__codelineno-5-215"></a>
</span><span id="__span-5-216"><a id="__codelineno-5-216" name="__codelineno-5-216" href="#__codelineno-5-216"></a><span class="k">def</span><span class="w"> </span><span class="nf">assign_count_based_representative</span><span class="p">(</span><span class="n">rep_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
</span><span id="__span-5-217"><a id="__codelineno-5-217" name="__codelineno-5-217" href="#__codelineno-5-217"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-218"><a id="__codelineno-5-218" name="__codelineno-5-218" href="#__codelineno-5-218"></a><span class="sd">    For each cluster, find the representative with the highest count.</span>
</span><span id="__span-5-219"><a id="__codelineno-5-219" name="__codelineno-5-219" href="#__codelineno-5-219"></a><span class="sd">    If &#39;count&#39; column is not available, falls back to medoid logic.</span>
</span><span id="__span-5-220"><a id="__codelineno-5-220" name="__codelineno-5-220" href="#__codelineno-5-220"></a><span class="sd">    Returns dict: cluster_label -&gt; count_based_rep_id</span>
</span><span id="__span-5-221"><a id="__codelineno-5-221" name="__codelineno-5-221" href="#__codelineno-5-221"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-222"><a id="__codelineno-5-222" name="__codelineno-5-222" href="#__codelineno-5-222"></a>    <span class="n">cluster_rep_ids</span> <span class="o">=</span> <span class="p">{}</span>
</span><span id="__span-5-223"><a id="__codelineno-5-223" name="__codelineno-5-223" href="#__codelineno-5-223"></a>    <span class="k">if</span> <span class="s2">&quot;count&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rep_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
</span><span id="__span-5-224"><a id="__codelineno-5-224" name="__codelineno-5-224" href="#__codelineno-5-224"></a>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;count&#39; column not found in representative DataFrame. Falling back to medoid-based representatives.&quot;</span><span class="p">)</span>
</span><span id="__span-5-225"><a id="__codelineno-5-225" name="__codelineno-5-225" href="#__codelineno-5-225"></a>        <span class="n">embeddings_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;embedding&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</span><span id="__span-5-226"><a id="__codelineno-5-226" name="__codelineno-5-226" href="#__codelineno-5-226"></a>        <span class="k">return</span> <span class="n">assign_medoid_representative</span><span class="p">(</span><span class="n">embeddings_array</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</span><span id="__span-5-227"><a id="__codelineno-5-227" name="__codelineno-5-227" href="#__codelineno-5-227"></a>
</span><span id="__span-5-228"><a id="__codelineno-5-228" name="__codelineno-5-228" href="#__codelineno-5-228"></a>    <span class="k">for</span> <span class="n">cluster_label</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">):</span>
</span><span id="__span-5-229"><a id="__codelineno-5-229" name="__codelineno-5-229" href="#__codelineno-5-229"></a>        <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span><span id="__span-5-230"><a id="__codelineno-5-230" name="__codelineno-5-230" href="#__codelineno-5-230"></a>            <span class="k">continue</span>
</span><span id="__span-5-231"><a id="__codelineno-5-231" name="__codelineno-5-231" href="#__codelineno-5-231"></a>
</span><span id="__span-5-232"><a id="__codelineno-5-232" name="__codelineno-5-232" href="#__codelineno-5-232"></a>        <span class="n">cluster_rows</span> <span class="o">=</span> <span class="n">rep_df</span><span class="p">[</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster_label</span><span class="p">]</span>
</span><span id="__span-5-233"><a id="__codelineno-5-233" name="__codelineno-5-233" href="#__codelineno-5-233"></a>
</span><span id="__span-5-234"><a id="__codelineno-5-234" name="__codelineno-5-234" href="#__codelineno-5-234"></a>        <span class="c1"># Find the row with the maximum count</span>
</span><span id="__span-5-235"><a id="__codelineno-5-235" name="__codelineno-5-235" href="#__codelineno-5-235"></a>        <span class="c1"># In case of a tie, `idxmax` will return the first occurrence, which is fine</span>
</span><span id="__span-5-236"><a id="__codelineno-5-236" name="__codelineno-5-236" href="#__codelineno-5-236"></a>        <span class="n">max_count_row</span> <span class="o">=</span> <span class="n">cluster_rows</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">cluster_rows</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()]</span>
</span><span id="__span-5-237"><a id="__codelineno-5-237" name="__codelineno-5-237" href="#__codelineno-5-237"></a>
</span><span id="__span-5-238"><a id="__codelineno-5-238" name="__codelineno-5-238" href="#__codelineno-5-238"></a>        <span class="n">cluster_rep_ids</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_count_row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
</span><span id="__span-5-239"><a id="__codelineno-5-239" name="__codelineno-5-239" href="#__codelineno-5-239"></a>
</span><span id="__span-5-240"><a id="__codelineno-5-240" name="__codelineno-5-240" href="#__codelineno-5-240"></a>    <span class="k">return</span> <span class="n">cluster_rep_ids</span>
</span><span id="__span-5-241"><a id="__codelineno-5-241" name="__codelineno-5-241" href="#__codelineno-5-241"></a>
</span><span id="__span-5-242"><a id="__codelineno-5-242" name="__codelineno-5-242" href="#__codelineno-5-242"></a>
</span><span id="__span-5-243"><a id="__codelineno-5-243" name="__codelineno-5-243" href="#__codelineno-5-243"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-244"><a id="__codelineno-5-244" name="__codelineno-5-244" href="#__codelineno-5-244"></a><span class="c1"># Step 6: Build Final DataFrame with cluster_id and cluster_rep_id per original id</span>
</span><span id="__span-5-245"><a id="__codelineno-5-245" name="__codelineno-5-245" href="#__codelineno-5-245"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-246"><a id="__codelineno-5-246" name="__codelineno-5-246" href="#__codelineno-5-246"></a>
</span><span id="__span-5-247"><a id="__codelineno-5-247" name="__codelineno-5-247" href="#__codelineno-5-247"></a><span class="k">def</span><span class="w"> </span><span class="nf">build_final_mapping</span><span class="p">(</span>
</span><span id="__span-5-248"><a id="__codelineno-5-248" name="__codelineno-5-248" href="#__codelineno-5-248"></a>    <span class="n">full_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
</span><span id="__span-5-249"><a id="__codelineno-5-249" name="__codelineno-5-249" href="#__codelineno-5-249"></a>    <span class="n">rep_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
</span><span id="__span-5-250"><a id="__codelineno-5-250" name="__codelineno-5-250" href="#__codelineno-5-250"></a>    <span class="n">rep_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
</span><span id="__span-5-251"><a id="__codelineno-5-251" name="__codelineno-5-251" href="#__codelineno-5-251"></a>    <span class="n">cluster_labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
</span><span id="__span-5-252"><a id="__codelineno-5-252" name="__codelineno-5-252" href="#__codelineno-5-252"></a>    <span class="n">use_count_rep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="__span-5-253"><a id="__codelineno-5-253" name="__codelineno-5-253" href="#__codelineno-5-253"></a><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
</span><span id="__span-5-254"><a id="__codelineno-5-254" name="__codelineno-5-254" href="#__codelineno-5-254"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-255"><a id="__codelineno-5-255" name="__codelineno-5-255" href="#__codelineno-5-255"></a><span class="sd">    Assign cluster_id and cluster_rep_id for all original ids.</span>
</span><span id="__span-5-256"><a id="__codelineno-5-256" name="__codelineno-5-256" href="#__codelineno-5-256"></a>
</span><span id="__span-5-257"><a id="__codelineno-5-257" name="__codelineno-5-257" href="#__codelineno-5-257"></a><span class="sd">    Args:</span>
</span><span id="__span-5-258"><a id="__codelineno-5-258" name="__codelineno-5-258" href="#__codelineno-5-258"></a><span class="sd">        full_df: DataFrame with all original ids, names, embeddings, and optionally a &#39;count&#39; column.</span>
</span><span id="__span-5-259"><a id="__codelineno-5-259" name="__codelineno-5-259" href="#__codelineno-5-259"></a><span class="sd">        rep_df: DataFrame with representatives only, their embeddings and cluster labels.</span>
</span><span id="__span-5-260"><a id="__codelineno-5-260" name="__codelineno-5-260" href="#__codelineno-5-260"></a><span class="sd">        rep_map: map original name -&gt; representative name (string)</span>
</span><span id="__span-5-261"><a id="__codelineno-5-261" name="__codelineno-5-261" href="#__codelineno-5-261"></a><span class="sd">        cluster_labels: HDBSCAN cluster labels for rep_df rows.</span>
</span><span id="__span-5-262"><a id="__codelineno-5-262" name="__codelineno-5-262" href="#__codelineno-5-262"></a><span class="sd">        use_count_rep: If True, uses the highest-count item as cluster representative.</span>
</span><span id="__span-5-263"><a id="__codelineno-5-263" name="__codelineno-5-263" href="#__codelineno-5-263"></a><span class="sd">                       Otherwise, uses the medoid.</span>
</span><span id="__span-5-264"><a id="__codelineno-5-264" name="__codelineno-5-264" href="#__codelineno-5-264"></a>
</span><span id="__span-5-265"><a id="__codelineno-5-265" name="__codelineno-5-265" href="#__codelineno-5-265"></a><span class="sd">    Returns:</span>
</span><span id="__span-5-266"><a id="__codelineno-5-266" name="__codelineno-5-266" href="#__codelineno-5-266"></a><span class="sd">        DataFrame with columns: id, name, cluster_id, cluster_rep_id, count (if present in input)</span>
</span><span id="__span-5-267"><a id="__codelineno-5-267" name="__codelineno-5-267" href="#__codelineno-5-267"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-268"><a id="__codelineno-5-268" name="__codelineno-5-268" href="#__codelineno-5-268"></a>    <span class="n">rep_df</span> <span class="o">=</span> <span class="n">rep_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span><span id="__span-5-269"><a id="__codelineno-5-269" name="__codelineno-5-269" href="#__codelineno-5-269"></a>    <span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;cluster_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_labels</span>
</span><span id="__span-5-270"><a id="__codelineno-5-270" name="__codelineno-5-270" href="#__codelineno-5-270"></a>
</span><span id="__span-5-271"><a id="__codelineno-5-271" name="__codelineno-5-271" href="#__codelineno-5-271"></a>    <span class="c1"># Choose representative assignment method</span>
</span><span id="__span-5-272"><a id="__codelineno-5-272" name="__codelineno-5-272" href="#__codelineno-5-272"></a>    <span class="k">if</span> <span class="n">use_count_rep</span> <span class="ow">and</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">rep_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
</span><span id="__span-5-273"><a id="__codelineno-5-273" name="__codelineno-5-273" href="#__codelineno-5-273"></a>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assigning cluster representatives based on highest count...&quot;</span><span class="p">)</span>
</span><span id="__span-5-274"><a id="__codelineno-5-274" name="__codelineno-5-274" href="#__codelineno-5-274"></a>        <span class="n">cluster_rep_map</span> <span class="o">=</span> <span class="n">assign_count_based_representative</span><span class="p">(</span><span class="n">rep_df</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">)</span>
</span><span id="__span-5-275"><a id="__codelineno-5-275" name="__codelineno-5-275" href="#__codelineno-5-275"></a>    <span class="k">else</span><span class="p">:</span>
</span><span id="__span-5-276"><a id="__codelineno-5-276" name="__codelineno-5-276" href="#__codelineno-5-276"></a>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Assigning cluster representatives based on medoid (closest to centroid)...&quot;</span><span class="p">)</span>
</span><span id="__span-5-277"><a id="__codelineno-5-277" name="__codelineno-5-277" href="#__codelineno-5-277"></a>        <span class="n">embeddings_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;embedding&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</span><span id="__span-5-278"><a id="__codelineno-5-278" name="__codelineno-5-278" href="#__codelineno-5-278"></a>        <span class="n">cluster_rep_map</span> <span class="o">=</span> <span class="n">assign_medoid_representative</span><span class="p">(</span><span class="n">embeddings_array</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
</span><span id="__span-5-279"><a id="__codelineno-5-279" name="__codelineno-5-279" href="#__codelineno-5-279"></a>
</span><span id="__span-5-280"><a id="__codelineno-5-280" name="__codelineno-5-280" href="#__codelineno-5-280"></a>    <span class="c1"># Map representative name to ID</span>
</span><span id="__span-5-281"><a id="__codelineno-5-281" name="__codelineno-5-281" href="#__codelineno-5-281"></a>    <span class="n">rep_name_to_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]))</span>
</span><span id="__span-5-282"><a id="__codelineno-5-282" name="__codelineno-5-282" href="#__codelineno-5-282"></a>
</span><span id="__span-5-283"><a id="__codelineno-5-283" name="__codelineno-5-283" href="#__codelineno-5-283"></a>    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
</span><span id="__span-5-284"><a id="__codelineno-5-284" name="__codelineno-5-284" href="#__codelineno-5-284"></a>    <span class="n">noise_count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="__span-5-285"><a id="__codelineno-5-285" name="__codelineno-5-285" href="#__codelineno-5-285"></a>    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_df</span><span class="p">)</span>
</span><span id="__span-5-286"><a id="__codelineno-5-286" name="__codelineno-5-286" href="#__codelineno-5-286"></a>    <span class="n">total_count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span id="__span-5-287"><a id="__codelineno-5-287" name="__codelineno-5-287" href="#__codelineno-5-287"></a>
</span><span id="__span-5-288"><a id="__codelineno-5-288" name="__codelineno-5-288" href="#__codelineno-5-288"></a>    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">full_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
</span><span id="__span-5-289"><a id="__codelineno-5-289" name="__codelineno-5-289" href="#__codelineno-5-289"></a>        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
</span><span id="__span-5-290"><a id="__codelineno-5-290" name="__codelineno-5-290" href="#__codelineno-5-290"></a>        <span class="n">orig_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
</span><span id="__span-5-291"><a id="__codelineno-5-291" name="__codelineno-5-291" href="#__codelineno-5-291"></a>        <span class="n">count</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Default to 1 if no count column</span>
</span><span id="__span-5-292"><a id="__codelineno-5-292" name="__codelineno-5-292" href="#__codelineno-5-292"></a>        <span class="n">total_count</span> <span class="o">+=</span> <span class="n">count</span>
</span><span id="__span-5-293"><a id="__codelineno-5-293" name="__codelineno-5-293" href="#__codelineno-5-293"></a>
</span><span id="__span-5-294"><a id="__codelineno-5-294" name="__codelineno-5-294" href="#__codelineno-5-294"></a>        <span class="n">rep_name</span> <span class="o">=</span> <span class="n">rep_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</span><span id="__span-5-295"><a id="__codelineno-5-295" name="__codelineno-5-295" href="#__codelineno-5-295"></a>        <span class="n">rep_id</span> <span class="o">=</span> <span class="n">rep_name_to_id</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rep_name</span><span class="p">)</span>
</span><span id="__span-5-296"><a id="__codelineno-5-296" name="__codelineno-5-296" href="#__codelineno-5-296"></a>
</span><span id="__span-5-297"><a id="__codelineno-5-297" name="__codelineno-5-297" href="#__codelineno-5-297"></a>        <span class="n">cluster_id</span> <span class="o">=</span> <span class="kc">None</span>
</span><span id="__span-5-298"><a id="__codelineno-5-298" name="__codelineno-5-298" href="#__codelineno-5-298"></a>        <span class="k">if</span> <span class="n">rep_id</span><span class="p">:</span>
</span><span id="__span-5-299"><a id="__codelineno-5-299" name="__codelineno-5-299" href="#__codelineno-5-299"></a>            <span class="n">rep_cluster_idx</span> <span class="o">=</span> <span class="n">rep_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">rep_id</span><span class="p">]</span>
</span><span id="__span-5-300"><a id="__codelineno-5-300" name="__codelineno-5-300" href="#__codelineno-5-300"></a>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rep_cluster_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span><span id="__span-5-301"><a id="__codelineno-5-301" name="__codelineno-5-301" href="#__codelineno-5-301"></a>                <span class="n">cluster_id</span> <span class="o">=</span> <span class="n">rep_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rep_cluster_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;cluster_id&quot;</span><span class="p">]</span>
</span><span id="__span-5-302"><a id="__codelineno-5-302" name="__codelineno-5-302" href="#__codelineno-5-302"></a>
</span><span id="__span-5-303"><a id="__codelineno-5-303" name="__codelineno-5-303" href="#__codelineno-5-303"></a>        <span class="k">if</span> <span class="n">cluster_id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
</span><span id="__span-5-304"><a id="__codelineno-5-304" name="__codelineno-5-304" href="#__codelineno-5-304"></a>            <span class="n">cluster_rep_id</span> <span class="o">=</span> <span class="n">rep_id</span>
</span><span id="__span-5-305"><a id="__codelineno-5-305" name="__codelineno-5-305" href="#__codelineno-5-305"></a>            <span class="n">noise_count</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span id="__span-5-306"><a id="__codelineno-5-306" name="__codelineno-5-306" href="#__codelineno-5-306"></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="__span-5-307"><a id="__codelineno-5-307" name="__codelineno-5-307" href="#__codelineno-5-307"></a>            <span class="n">cluster_rep_id</span> <span class="o">=</span> <span class="n">cluster_rep_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cluster_id</span><span class="p">,</span> <span class="n">rep_id</span><span class="p">)</span>
</span><span id="__span-5-308"><a id="__codelineno-5-308" name="__codelineno-5-308" href="#__codelineno-5-308"></a>
</span><span id="__span-5-309"><a id="__codelineno-5-309" name="__codelineno-5-309" href="#__codelineno-5-309"></a>        <span class="n">row_data</span> <span class="o">=</span> <span class="p">{</span>
</span><span id="__span-5-310"><a id="__codelineno-5-310" name="__codelineno-5-310" href="#__codelineno-5-310"></a>            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">orig_id</span><span class="p">,</span>
</span><span id="__span-5-311"><a id="__codelineno-5-311" name="__codelineno-5-311" href="#__codelineno-5-311"></a>            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
</span><span id="__span-5-312"><a id="__codelineno-5-312" name="__codelineno-5-312" href="#__codelineno-5-312"></a>            <span class="s2">&quot;cluster_id&quot;</span><span class="p">:</span> <span class="n">cluster_id</span><span class="p">,</span>
</span><span id="__span-5-313"><a id="__codelineno-5-313" name="__codelineno-5-313" href="#__codelineno-5-313"></a>            <span class="s2">&quot;cluster_rep_id&quot;</span><span class="p">:</span> <span class="n">cluster_rep_id</span><span class="p">,</span>
</span><span id="__span-5-314"><a id="__codelineno-5-314" name="__codelineno-5-314" href="#__codelineno-5-314"></a>        <span class="p">}</span>
</span><span id="__span-5-315"><a id="__codelineno-5-315" name="__codelineno-5-315" href="#__codelineno-5-315"></a>        <span class="k">if</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">full_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
</span><span id="__span-5-316"><a id="__codelineno-5-316" name="__codelineno-5-316" href="#__codelineno-5-316"></a>            <span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
</span><span id="__span-5-317"><a id="__codelineno-5-317" name="__codelineno-5-317" href="#__codelineno-5-317"></a>
</span><span id="__span-5-318"><a id="__codelineno-5-318" name="__codelineno-5-318" href="#__codelineno-5-318"></a>        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>
</span><span id="__span-5-319"><a id="__codelineno-5-319" name="__codelineno-5-319" href="#__codelineno-5-319"></a>
</span><span id="__span-5-320"><a id="__codelineno-5-320" name="__codelineno-5-320" href="#__codelineno-5-320"></a>    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span><span id="__span-5-321"><a id="__codelineno-5-321" name="__codelineno-5-321" href="#__codelineno-5-321"></a>
</span><span id="__span-5-322"><a id="__codelineno-5-322" name="__codelineno-5-322" href="#__codelineno-5-322"></a>    <span class="c1"># Log cluster summary</span>
</span><span id="__span-5-323"><a id="__codelineno-5-323" name="__codelineno-5-323" href="#__codelineno-5-323"></a>    <span class="n">num_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">cluster_labels</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
</span><span id="__span-5-324"><a id="__codelineno-5-324" name="__codelineno-5-324" href="#__codelineno-5-324"></a>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;‚úÖ Mapping complete: </span><span class="si">{</span><span class="n">total</span><span class="si">}</span><span class="s2"> rows, </span><span class="si">{</span><span class="n">total_count</span><span class="si">}</span><span class="s2"> total count&quot;</span><span class="p">)</span>
</span><span id="__span-5-325"><a id="__codelineno-5-325" name="__codelineno-5-325" href="#__codelineno-5-325"></a>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üì¶ </span><span class="si">{</span><span class="n">num_clusters</span><span class="si">}</span><span class="s2"> clusters formed&quot;</span><span class="p">)</span>
</span><span id="__span-5-326"><a id="__codelineno-5-326" name="__codelineno-5-326" href="#__codelineno-5-326"></a>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üå™Ô∏è </span><span class="si">{</span><span class="n">noise_count</span><span class="si">}</span><span class="s2"> items marked as noise (singleton clusters)&quot;</span><span class="p">)</span>
</span><span id="__span-5-327"><a id="__codelineno-5-327" name="__codelineno-5-327" href="#__codelineno-5-327"></a>
</span><span id="__span-5-328"><a id="__codelineno-5-328" name="__codelineno-5-328" href="#__codelineno-5-328"></a>    <span class="c1"># Optional: Summary of total count per cluster rep</span>
</span><span id="__span-5-329"><a id="__codelineno-5-329" name="__codelineno-5-329" href="#__codelineno-5-329"></a>    <span class="k">if</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">result_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
</span><span id="__span-5-330"><a id="__codelineno-5-330" name="__codelineno-5-330" href="#__codelineno-5-330"></a>        <span class="n">cluster_summary</span> <span class="o">=</span> <span class="p">(</span>
</span><span id="__span-5-331"><a id="__codelineno-5-331" name="__codelineno-5-331" href="#__codelineno-5-331"></a>            <span class="n">result_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cluster_rep_id&quot;</span><span class="p">)[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span>
</span><span id="__span-5-332"><a id="__codelineno-5-332" name="__codelineno-5-332" href="#__codelineno-5-332"></a>            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</span><span id="__span-5-333"><a id="__codelineno-5-333" name="__codelineno-5-333" href="#__codelineno-5-333"></a>            <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</span><span id="__span-5-334"><a id="__codelineno-5-334" name="__codelineno-5-334" href="#__codelineno-5-334"></a>        <span class="p">)</span>
</span><span id="__span-5-335"><a id="__codelineno-5-335" name="__codelineno-5-335" href="#__codelineno-5-335"></a>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">üî¢ Top cluster representatives by total count:&quot;</span><span class="p">)</span>
</span><span id="__span-5-336"><a id="__codelineno-5-336" name="__codelineno-5-336" href="#__codelineno-5-336"></a>        <span class="nb">print</span><span class="p">(</span><span class="n">cluster_summary</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span><span id="__span-5-337"><a id="__codelineno-5-337" name="__codelineno-5-337" href="#__codelineno-5-337"></a>
</span><span id="__span-5-338"><a id="__codelineno-5-338" name="__codelineno-5-338" href="#__codelineno-5-338"></a>    <span class="k">return</span> <span class="n">result_df</span>
</span><span id="__span-5-339"><a id="__codelineno-5-339" name="__codelineno-5-339" href="#__codelineno-5-339"></a>
</span><span id="__span-5-340"><a id="__codelineno-5-340" name="__codelineno-5-340" href="#__codelineno-5-340"></a>
</span><span id="__span-5-341"><a id="__codelineno-5-341" name="__codelineno-5-341" href="#__codelineno-5-341"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-342"><a id="__codelineno-5-342" name="__codelineno-5-342" href="#__codelineno-5-342"></a><span class="c1"># Main pipeline function</span>
</span><span id="__span-5-343"><a id="__codelineno-5-343" name="__codelineno-5-343" href="#__codelineno-5-343"></a><span class="c1"># ----------------------------------------</span>
</span><span id="__span-5-344"><a id="__codelineno-5-344" name="__codelineno-5-344" href="#__codelineno-5-344"></a>
</span><span id="__span-5-345"><a id="__codelineno-5-345" name="__codelineno-5-345" href="#__codelineno-5-345"></a><span class="k">def</span><span class="w"> </span><span class="nf">full_deduplication_pipeline</span><span class="p">(</span>
</span><span id="__span-5-346"><a id="__codelineno-5-346" name="__codelineno-5-346" href="#__codelineno-5-346"></a>    <span class="n">all_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
</span><span id="__span-5-347"><a id="__codelineno-5-347" name="__codelineno-5-347" href="#__codelineno-5-347"></a>    <span class="n">full_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
</span><span id="__span-5-348"><a id="__codelineno-5-348" name="__codelineno-5-348" href="#__codelineno-5-348"></a>    <span class="n">minhash_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
</span><span id="__span-5-349"><a id="__codelineno-5-349" name="__codelineno-5-349" href="#__codelineno-5-349"></a>    <span class="n">num_perm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
</span><span id="__span-5-350"><a id="__codelineno-5-350" name="__codelineno-5-350" href="#__codelineno-5-350"></a>    <span class="n">hdbscan_min_cluster_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
</span><span id="__span-5-351"><a id="__codelineno-5-351" name="__codelineno-5-351" href="#__codelineno-5-351"></a>    <span class="n">hdbscan_min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="__span-5-352"><a id="__codelineno-5-352" name="__codelineno-5-352" href="#__codelineno-5-352"></a>    <span class="n">epsilon_value</span><span class="p">:</span><span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
</span><span id="__span-5-353"><a id="__codelineno-5-353" name="__codelineno-5-353" href="#__codelineno-5-353"></a>    <span class="n">use_count_rep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
</span><span id="__span-5-354"><a id="__codelineno-5-354" name="__codelineno-5-354" href="#__codelineno-5-354"></a><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
</span><span id="__span-5-355"><a id="__codelineno-5-355" name="__codelineno-5-355" href="#__codelineno-5-355"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-356"><a id="__codelineno-5-356" name="__codelineno-5-356" href="#__codelineno-5-356"></a><span class="sd">    Run full deduplication pipeline:</span>
</span><span id="__span-5-357"><a id="__codelineno-5-357" name="__codelineno-5-357" href="#__codelineno-5-357"></a><span class="sd">    1. MinHash deduplication on names</span>
</span><span id="__span-5-358"><a id="__codelineno-5-358" name="__codelineno-5-358" href="#__codelineno-5-358"></a><span class="sd">    2. Load embeddings and IDs from ChromaDB collections -- this wil be done before</span>
</span><span id="__span-5-359"><a id="__codelineno-5-359" name="__codelineno-5-359" href="#__codelineno-5-359"></a><span class="sd">    3. Filter embeddings to MinHash cluster representatives</span>
</span><span id="__span-5-360"><a id="__codelineno-5-360" name="__codelineno-5-360" href="#__codelineno-5-360"></a><span class="sd">    4. Run HDBSCAN on embeddings of representatives</span>
</span><span id="__span-5-361"><a id="__codelineno-5-361" name="__codelineno-5-361" href="#__codelineno-5-361"></a><span class="sd">    5. Assign medoid representatives per cluster</span>
</span><span id="__span-5-362"><a id="__codelineno-5-362" name="__codelineno-5-362" href="#__codelineno-5-362"></a><span class="sd">    6. Map all original ids to cluster_id and cluster_rep_id</span>
</span><span id="__span-5-363"><a id="__codelineno-5-363" name="__codelineno-5-363" href="#__codelineno-5-363"></a>
</span><span id="__span-5-364"><a id="__codelineno-5-364" name="__codelineno-5-364" href="#__codelineno-5-364"></a><span class="sd">    Returns:</span>
</span><span id="__span-5-365"><a id="__codelineno-5-365" name="__codelineno-5-365" href="#__codelineno-5-365"></a><span class="sd">        DataFrame with columns: id, name, cluster_id, cluster_rep_id</span>
</span><span id="__span-5-366"><a id="__codelineno-5-366" name="__codelineno-5-366" href="#__codelineno-5-366"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-367"><a id="__codelineno-5-367" name="__codelineno-5-367" href="#__codelineno-5-367"></a>
</span><span id="__span-5-368"><a id="__codelineno-5-368" name="__codelineno-5-368" href="#__codelineno-5-368"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running MinHash deduplication on names...&quot;</span><span class="p">)</span>
</span><span id="__span-5-369"><a id="__codelineno-5-369" name="__codelineno-5-369" href="#__codelineno-5-369"></a>    <span class="c1"># Get a Series of counts for MinHash clustering representative selection</span>
</span><span id="__span-5-370"><a id="__codelineno-5-370" name="__codelineno-5-370" href="#__codelineno-5-370"></a>    <span class="k">if</span> <span class="s2">&quot;count&quot;</span> <span class="ow">in</span> <span class="n">full_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
</span><span id="__span-5-371"><a id="__codelineno-5-371" name="__codelineno-5-371" href="#__codelineno-5-371"></a>        <span class="n">name_counts</span> <span class="o">=</span> <span class="n">full_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</span><span id="__span-5-372"><a id="__codelineno-5-372" name="__codelineno-5-372" href="#__codelineno-5-372"></a>    <span class="k">else</span><span class="p">:</span>
</span><span id="__span-5-373"><a id="__codelineno-5-373" name="__codelineno-5-373" href="#__codelineno-5-373"></a>        <span class="n">name_counts</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">full_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
</span><span id="__span-5-374"><a id="__codelineno-5-374" name="__codelineno-5-374" href="#__codelineno-5-374"></a>
</span><span id="__span-5-375"><a id="__codelineno-5-375" name="__codelineno-5-375" href="#__codelineno-5-375"></a>    <span class="n">clusters</span> <span class="o">=</span> <span class="n">minhash_cluster</span><span class="p">(</span><span class="n">all_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">minhash_threshold</span><span class="p">,</span> <span class="n">num_perm</span><span class="o">=</span><span class="n">num_perm</span><span class="p">)</span>
</span><span id="__span-5-376"><a id="__codelineno-5-376" name="__codelineno-5-376" href="#__codelineno-5-376"></a>    <span class="n">rep_map</span> <span class="o">=</span> <span class="n">get_cluster_representatives</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">name_counts</span><span class="p">)</span>
</span><span id="__span-5-377"><a id="__codelineno-5-377" name="__codelineno-5-377" href="#__codelineno-5-377"></a>
</span><span id="__span-5-378"><a id="__codelineno-5-378" name="__codelineno-5-378" href="#__codelineno-5-378"></a>
</span><span id="__span-5-379"><a id="__codelineno-5-379" name="__codelineno-5-379" href="#__codelineno-5-379"></a>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering embeddings to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rep_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="si">}</span><span class="s2"> cluster representatives...&quot;</span><span class="p">)</span>
</span><span id="__span-5-380"><a id="__codelineno-5-380" name="__codelineno-5-380" href="#__codelineno-5-380"></a>    <span class="n">rep_df</span> <span class="o">=</span> <span class="n">filter_to_representatives</span><span class="p">(</span><span class="n">full_df</span><span class="p">,</span> <span class="n">rep_map</span><span class="p">)</span>
</span><span id="__span-5-381"><a id="__codelineno-5-381" name="__codelineno-5-381" href="#__codelineno-5-381"></a>
</span><span id="__span-5-382"><a id="__codelineno-5-382" name="__codelineno-5-382" href="#__codelineno-5-382"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running HDBSCAN on representative embeddings...&quot;</span><span class="p">)</span>
</span><span id="__span-5-383"><a id="__codelineno-5-383" name="__codelineno-5-383" href="#__codelineno-5-383"></a>    <span class="n">embeddings_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;embedding&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</span><span id="__span-5-384"><a id="__codelineno-5-384" name="__codelineno-5-384" href="#__codelineno-5-384"></a>    <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">hdbscan_cluster_embeddings</span><span class="p">(</span>
</span><span id="__span-5-385"><a id="__codelineno-5-385" name="__codelineno-5-385" href="#__codelineno-5-385"></a>        <span class="n">embeddings_array</span><span class="p">,</span> 
</span><span id="__span-5-386"><a id="__codelineno-5-386" name="__codelineno-5-386" href="#__codelineno-5-386"></a>        <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">hdbscan_min_cluster_size</span><span class="p">,</span> 
</span><span id="__span-5-387"><a id="__codelineno-5-387" name="__codelineno-5-387" href="#__codelineno-5-387"></a>        <span class="n">min_samples</span><span class="o">=</span><span class="n">hdbscan_min_samples</span><span class="p">,</span> 
</span><span id="__span-5-388"><a id="__codelineno-5-388" name="__codelineno-5-388" href="#__codelineno-5-388"></a>        <span class="n">epsilon_value</span> <span class="o">=</span> <span class="n">epsilon_value</span>
</span><span id="__span-5-389"><a id="__codelineno-5-389" name="__codelineno-5-389" href="#__codelineno-5-389"></a>    <span class="p">)</span>
</span><span id="__span-5-390"><a id="__codelineno-5-390" name="__codelineno-5-390" href="#__codelineno-5-390"></a>    <span class="c1"># cluster_labels = dbscan_cluster_embeddings(</span>
</span><span id="__span-5-391"><a id="__codelineno-5-391" name="__codelineno-5-391" href="#__codelineno-5-391"></a>    <span class="c1">#     embeddings_array, </span>
</span><span id="__span-5-392"><a id="__codelineno-5-392" name="__codelineno-5-392" href="#__codelineno-5-392"></a>    <span class="c1">#     min_cluster_size=hdbscan_min_cluster_size, </span>
</span><span id="__span-5-393"><a id="__codelineno-5-393" name="__codelineno-5-393" href="#__codelineno-5-393"></a>    <span class="c1">#     min_samples=hdbscan_min_samples, </span>
</span><span id="__span-5-394"><a id="__codelineno-5-394" name="__codelineno-5-394" href="#__codelineno-5-394"></a>    <span class="c1">#     epsilon_value = epsilon_value</span>
</span><span id="__span-5-395"><a id="__codelineno-5-395" name="__codelineno-5-395" href="#__codelineno-5-395"></a>    <span class="c1"># )</span>
</span><span id="__span-5-396"><a id="__codelineno-5-396" name="__codelineno-5-396" href="#__codelineno-5-396"></a>
</span><span id="__span-5-397"><a id="__codelineno-5-397" name="__codelineno-5-397" href="#__codelineno-5-397"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building final mapping of all IDs to cluster IDs and representative IDs...&quot;</span><span class="p">)</span>
</span><span id="__span-5-398"><a id="__codelineno-5-398" name="__codelineno-5-398" href="#__codelineno-5-398"></a>    <span class="n">final_df</span> <span class="o">=</span> <span class="n">build_final_mapping</span><span class="p">(</span><span class="n">full_df</span><span class="p">,</span> <span class="n">rep_df</span><span class="p">,</span> <span class="n">rep_map</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">,</span> <span class="n">use_count_rep</span><span class="o">=</span><span class="n">use_count_rep</span><span class="p">)</span>
</span><span id="__span-5-399"><a id="__codelineno-5-399" name="__codelineno-5-399" href="#__codelineno-5-399"></a>
</span><span id="__span-5-400"><a id="__codelineno-5-400" name="__codelineno-5-400" href="#__codelineno-5-400"></a>    <span class="k">return</span> <span class="n">final_df</span>
</span><span id="__span-5-401"><a id="__codelineno-5-401" name="__codelineno-5-401" href="#__codelineno-5-401"></a>
</span><span id="__span-5-402"><a id="__codelineno-5-402" name="__codelineno-5-402" href="#__codelineno-5-402"></a><span class="k">def</span><span class="w"> </span><span class="nf">deduplication_pipeline_testing</span><span class="p">(</span>
</span><span id="__span-5-403"><a id="__codelineno-5-403" name="__codelineno-5-403" href="#__codelineno-5-403"></a>    <span class="n">all_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
</span><span id="__span-5-404"><a id="__codelineno-5-404" name="__codelineno-5-404" href="#__codelineno-5-404"></a>    <span class="n">full_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
</span><span id="__span-5-405"><a id="__codelineno-5-405" name="__codelineno-5-405" href="#__codelineno-5-405"></a>    <span class="n">rep_map</span><span class="p">,</span>
</span><span id="__span-5-406"><a id="__codelineno-5-406" name="__codelineno-5-406" href="#__codelineno-5-406"></a>    <span class="n">hdbscan_min_cluster_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
</span><span id="__span-5-407"><a id="__codelineno-5-407" name="__codelineno-5-407" href="#__codelineno-5-407"></a>    <span class="n">hdbscan_min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
</span><span id="__span-5-408"><a id="__codelineno-5-408" name="__codelineno-5-408" href="#__codelineno-5-408"></a><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
</span><span id="__span-5-409"><a id="__codelineno-5-409" name="__codelineno-5-409" href="#__codelineno-5-409"></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="__span-5-410"><a id="__codelineno-5-410" name="__codelineno-5-410" href="#__codelineno-5-410"></a><span class="sd">    Run full deduplication pipeline:</span>
</span><span id="__span-5-411"><a id="__codelineno-5-411" name="__codelineno-5-411" href="#__codelineno-5-411"></a><span class="sd">    1. MinHash deduplication on names</span>
</span><span id="__span-5-412"><a id="__codelineno-5-412" name="__codelineno-5-412" href="#__codelineno-5-412"></a><span class="sd">    2. Load embeddings and IDs from ChromaDB collections -- this wil be done before</span>
</span><span id="__span-5-413"><a id="__codelineno-5-413" name="__codelineno-5-413" href="#__codelineno-5-413"></a><span class="sd">    3. Filter embeddings to MinHash cluster representatives</span>
</span><span id="__span-5-414"><a id="__codelineno-5-414" name="__codelineno-5-414" href="#__codelineno-5-414"></a><span class="sd">    4. Run HDBSCAN on embeddings of representatives</span>
</span><span id="__span-5-415"><a id="__codelineno-5-415" name="__codelineno-5-415" href="#__codelineno-5-415"></a><span class="sd">    5. Assign medoid representatives per cluster</span>
</span><span id="__span-5-416"><a id="__codelineno-5-416" name="__codelineno-5-416" href="#__codelineno-5-416"></a><span class="sd">    6. Map all original ids to cluster_id and cluster_rep_id</span>
</span><span id="__span-5-417"><a id="__codelineno-5-417" name="__codelineno-5-417" href="#__codelineno-5-417"></a>
</span><span id="__span-5-418"><a id="__codelineno-5-418" name="__codelineno-5-418" href="#__codelineno-5-418"></a><span class="sd">    Returns:</span>
</span><span id="__span-5-419"><a id="__codelineno-5-419" name="__codelineno-5-419" href="#__codelineno-5-419"></a><span class="sd">        DataFrame with columns: id, name, cluster_id, cluster_rep_id</span>
</span><span id="__span-5-420"><a id="__codelineno-5-420" name="__codelineno-5-420" href="#__codelineno-5-420"></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="__span-5-421"><a id="__codelineno-5-421" name="__codelineno-5-421" href="#__codelineno-5-421"></a>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering embeddings to </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">rep_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="si">}</span><span class="s2"> cluster representatives...&quot;</span><span class="p">)</span>
</span><span id="__span-5-422"><a id="__codelineno-5-422" name="__codelineno-5-422" href="#__codelineno-5-422"></a>    <span class="n">rep_df</span> <span class="o">=</span> <span class="n">filter_to_representatives</span><span class="p">(</span><span class="n">full_df</span><span class="p">,</span> <span class="n">rep_map</span><span class="p">)</span>
</span><span id="__span-5-423"><a id="__codelineno-5-423" name="__codelineno-5-423" href="#__codelineno-5-423"></a>
</span><span id="__span-5-424"><a id="__codelineno-5-424" name="__codelineno-5-424" href="#__codelineno-5-424"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running HDBSCAN on representative embeddings...&quot;</span><span class="p">)</span>
</span><span id="__span-5-425"><a id="__codelineno-5-425" name="__codelineno-5-425" href="#__codelineno-5-425"></a>    <span class="n">embeddings_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">rep_df</span><span class="p">[</span><span class="s2">&quot;embedding&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
</span><span id="__span-5-426"><a id="__codelineno-5-426" name="__codelineno-5-426" href="#__codelineno-5-426"></a>    <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">hdbscan_cluster_embeddings</span><span class="p">(</span>
</span><span id="__span-5-427"><a id="__codelineno-5-427" name="__codelineno-5-427" href="#__codelineno-5-427"></a>        <span class="n">embeddings_array</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">hdbscan_min_cluster_size</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">hdbscan_min_samples</span>
</span><span id="__span-5-428"><a id="__codelineno-5-428" name="__codelineno-5-428" href="#__codelineno-5-428"></a>    <span class="p">)</span>
</span><span id="__span-5-429"><a id="__codelineno-5-429" name="__codelineno-5-429" href="#__codelineno-5-429"></a>
</span><span id="__span-5-430"><a id="__codelineno-5-430" name="__codelineno-5-430" href="#__codelineno-5-430"></a>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Building final mapping of all IDs to cluster IDs and representative IDs...&quot;</span><span class="p">)</span>
</span><span id="__span-5-431"><a id="__codelineno-5-431" name="__codelineno-5-431" href="#__codelineno-5-431"></a>    <span class="n">final_df</span> <span class="o">=</span> <span class="n">build_final_mapping</span><span class="p">(</span><span class="n">full_df</span><span class="p">,</span> <span class="n">rep_df</span><span class="p">,</span> <span class="n">rep_map</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">)</span>
</span><span id="__span-5-432"><a id="__codelineno-5-432" name="__codelineno-5-432" href="#__codelineno-5-432"></a>
</span><span id="__span-5-433"><a id="__codelineno-5-433" name="__codelineno-5-433" href="#__codelineno-5-433"></a>    <span class="k">return</span> <span class="n">final_df</span>
</span></code></pre></div></h2>
<h2 id="4-workdna-ontology-service">4. WorkDNA Ontology Service</h2>
<p>The <strong>WorkDNA Ontology Service</strong> is the core component that bridges the structured ontology with the cleaned and deduplicated capability dataset. After the capability table has been created, embedded, and clustered into unique entries (Step 1‚Äì3), the service provides functionality to load, interpret, and query the WorkDNA ontology in a systematic way. This enables mapping real-world capabilities to the WorkDNA ontology structure, ensuring semantic consistency and interoperability across applications.</p>
<h3 id="41-structure-of-the-ontology">4.1 Structure of the Ontology</h3>
<p>At its core, our WorkDNA ontology defines a taxonomy of professional identity, organized into seven primary node types:</p>
<ol>
<li>
<p><strong>Skills</strong> ‚Äì Developed capabilities that an individual must have to be effective in a job, role, function, task or duty (e.g., Python programming, financial modeling).</p>
</li>
<li>
<p><strong>Knowledges</strong> ‚Äì Organized sets of principles and practices used for the execution of tasks and activities within a particular domain (e.g., statistics, constitutional law).</p>
</li>
<li>
<p><strong>Personal Attributes</strong> ‚Äì Personal characteristics that are innate and developed through the social context and personal experiences to which the individual is exposed. These qualities influence the way one is and does things and are considered valuable assets for work performance (e.g., adaptability, critical thinking).</p>
</li>
<li>
<p><strong>Abilities</strong> ‚Äì Innate and developed aptitudes that facilitate the acquisition of knowledge and skills to carry out expected work (e.g., problem-solving, systems thinking).</p>
</li>
<li>
<p><strong>Motivations/Interests</strong> ‚Äì Preferences for work environments and outcomes (e.g., curiosity, achievement orientation).</p>
</li>
<li>
<p><strong>Work Contexts</strong> ‚Äì Physical, environmental, and social factors that influence the nature of work (e.g., startup setting, regulated industries).</p>
</li>
<li>
<p><strong>Work Activities</strong> ‚Äì General types of work-related activities (e.g., debugging code, conducting interviews).</p>
</li>
</ol>
<p>Each node is defined not only by its label but also by its relationships to other nodes, making the ontology a connected structure rather than a flat hierarchy.</p>
<h3 id="41-purpose">4.1 Purpose</h3>
<p>The service is designed to:
- Load the WorkDNA ontology from a <strong>Turtle (TTL)</strong> file, which encodes hierarchical relationships among nodes.
- Represent the ontology as a navigable structure, where each node corresponds to a defined WorkDNA category (e.g., Skill, Attribute, Ability).
- Support capability-to-ontology matching, allowing new or external capabilities to be classified under one of the predefined WorkDNA nodes.
- Provide querying and inspection tools for analyzing ontology nodes, relationships, and matched capabilities.</p>
<p>This abstraction makes it possible to align raw, unstructured capability data with the formal WorkDNA taxonomy.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../secret-manager/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Secret Manager">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Secret Manager
              </div>
            </div>
          </a>
        
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2025 Karrera.AI
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://www.google.com" target="_blank" rel="noopener" title="www.google.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.google.com" target="_blank" rel="noopener" title="www.google.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.498 6.186a3.02 3.02 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.02 3.02 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.02 3.02 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.02 3.02 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814M9.545 15.568V8.432L15.818 12z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "..", "features": ["navigation.footer"], "search": "../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>